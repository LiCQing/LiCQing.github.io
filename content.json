{"meta":{"title":"L","subtitle":"栗子树上苹果花","description":"废宅一个","author":"Li","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2019-04-04T09:42:39.000Z","updated":"2019-04-05T07:25:53.652Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"有关于你"},{"title":"categories","date":"2019-04-04T09:42:00.000Z","updated":"2019-04-04T10:01:10.759Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"我的标签","date":"2019-04-06T09:29:58.000Z","updated":"2019-04-06T09:34:41.626Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringMVC 拦截器浅析与实例","slug":"interceptor","date":"2019-04-12T07:27:18.000Z","updated":"2019-04-12T07:32:55.173Z","comments":true,"path":"2019/04/12/interceptor/","link":"","permalink":"http://yoursite.com/2019/04/12/interceptor/","excerpt":"SpringMVC 拦截器浅析与实例拦截器的作用，类似于传统servlet的过滤器Filter，在执行请求时，做出预处理，与后处理。不过拦截器中，还有一个中处理（暂且这么称呼）。过滤器我们通常用来执行权限验证，统计访问，计算处理时间等等。拦截器也一样，下面先看看DispatchServlet中拦截器的参与过程。","text":"SpringMVC 拦截器浅析与实例拦截器的作用，类似于传统servlet的过滤器Filter，在执行请求时，做出预处理，与后处理。不过拦截器中，还有一个中处理（暂且这么称呼）。过滤器我们通常用来执行权限验证，统计访问，计算处理时间等等。拦截器也一样，下面先看看DispatchServlet中拦截器的参与过程。 源码预览doDispatch这个方法是SpringMVC前端总控制器处理请求的方法，其中，有关拦截器的代码如下：其中的mappedHandler是一个局部HandlerExecutionChain属性，保存了真正的自定义处理器与拦截器链。 HandlerExecutionChain可以看到，其中有一个用来存储自定义的控制器的object，有一个存储拦截器的数组和列表。列表方便添加管理拦截器，数组能够快速通过下标进行访问。然后就有一个整型的下标，这个是用来存储预处理时，处理到了哪一个拦截器的下标。具体使用方法如下。这几个就是DispatchServlet中调用的方法。通过预处理和后处理的源码，不难看出下标的用途:顺序执行预处理，逆序执行后处理。同理，业是逆序执行中处理。同时，当发生异常时，保证了拦截器能从正确的下标执行后处理。 HandlerInterceptor拦截器的接口，自定义的拦截器需要实现该接口，同时覆写三个方法。HandlerExecutionChain中的预处理便是调用了每一个拦截器的实现方法。需要注意的是：预处理中返回的是布尔值，如果返回false，便会使整个doDispatch()方法返回，因此，该处理也就被忽视了。所以在需要返回false值之前，指定重定向的页面。不然就会显示一片空白。 使用示例登陆控制器1234567891011121314151617181920212223242526272829/** * @author !N * 2019年4月11日 */@Controllerpublic class LoginController &#123; @RequestMapping(&quot;/login&quot;) public String login(User user,HttpSession session,HttpServletRequest request,HttpServletResponse res)&#123; System.out.println(&quot;请求登陆&quot;); if(user.getName().equals(&quot;user&quot;) &amp;&amp; user.getPwd().equals(&quot;123&quot;))&#123; session.setAttribute(&quot;user&quot;, user); return &quot;redirect:/toindex&quot;; &#125; return &quot;redirect:/toindex&quot;; &#125; @RequestMapping(&quot;/gotomanage&quot;) public String managerPage()&#123; System.out.println(&quot;自定义处理器&quot;); return &quot;manage&quot;; &#125; @RequestMapping(&quot;/toindex&quot;) public String toIndex()&#123; return &quot;redirect:/index.jsp&quot;; &#125;&#125; 假定测试用户名和密码。利用session记录用户登陆状态。使用重定向返回首页（正常登陆成功之后跳转到其他页面，直接返回就好了）。 自定义拦截器1234567891011121314151617181920212223242526272829303132333435/** * @author !N * 2019年4月11日 * 权限拦截器 */public class PermissionInterceptor implements HandlerInterceptor&#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;Permision： 预处理，请求路径：&quot; + request.getRequestURI()); if(request.getSession().getAttribute(&quot;user&quot;)!=null)&#123; System.out.println(&quot;已经登陆&quot;); return true; &#125; System.out.println(&quot;未登陆，跳转到首页&quot;); response.sendRedirect(request.getContextPath() +&quot;/index.jsp&quot;); return false; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;=== 中处理 Post===&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;=== 后处理 After===&quot;); &#125; &#125; 利用session中的参数判断是否登陆。 jsp页面1234567&lt;a href=&quot;gotomanage&quot;&gt;进入后台&lt;/a&gt;&lt;br/&gt;&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;pwd&quot; &gt; &lt;input type = &quot;submit&quot; value=&quot;login&quot;&gt;&lt;/form&gt; 配置文件在配置servlet-web的文件中添加如下配置。1234567891011&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 配置拦截器需要拦截的路径 --&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt; &lt;!-- 配置不需要拦截作用的路径 --&gt; &lt;mvc:exclude-mapping path=&quot;/login&quot; /&gt; &lt;mvc:exclude-mapping path=&quot;/toindex&quot; /&gt; &lt;!-- 使用哪个拦截器 --&gt; &lt;bean class=&quot;com.jsu.handlernterceptor.PermissionInterceptor&quot; /&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 如果有异常可以更换如下xml文档头12345678910&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; 运行结果未登陆点击首页的进入后台登陆后点击进入后台（自己新建文件） 总结 拦截器有三个处理过程（前，中，后），分别在处理器之前；处理器后，视图解析前；视图解析后。 被拦截需要设置重定向加载页面。","categories":[{"name":"springmvc","slug":"springmvc","permalink":"http://yoursite.com/categories/springmvc/"}],"tags":[{"name":"springmvc","slug":"springmvc","permalink":"http://yoursite.com/tags/springmvc/"}]},{"title":"SpringMVC文件下载的两种方式","slug":"springmvcdownload","date":"2019-04-09T08:55:39.000Z","updated":"2019-04-09T08:58:02.648Z","comments":true,"path":"2019/04/09/springmvcdownload/","link":"","permalink":"http://yoursite.com/2019/04/09/springmvcdownload/","excerpt":"SpringMVC 实现文件下载文件利用程序实现下载需要设置两个报头： 1．Web服务器需要告诉浏览器其所输出内容的类型不是普通文本文件或HTML文件，而是一个要保存到本地的下载文件。设置Content-Type 的值为：application/x-msdownload。 2．Web服务器希望浏览器不直接处理相应的实体内容，而是由用户选择将相应的实体内容保存到一个文件中，这需要设置Content-Disposition报头。该报头指定了接收程序处理数据内容的方式，在HTTP应用中只有attachment是标准方式，attachment表示要求用户干预。在attachment后面还可以指定filename参数，该参数是服务器建议浏览器将实体内容保存到文件中的文件名称。","text":"SpringMVC 实现文件下载文件利用程序实现下载需要设置两个报头： 1．Web服务器需要告诉浏览器其所输出内容的类型不是普通文本文件或HTML文件，而是一个要保存到本地的下载文件。设置Content-Type 的值为：application/x-msdownload。 2．Web服务器希望浏览器不直接处理相应的实体内容，而是由用户选择将相应的实体内容保存到一个文件中，这需要设置Content-Disposition报头。该报头指定了接收程序处理数据内容的方式，在HTTP应用中只有attachment是标准方式，attachment表示要求用户干预。在attachment后面还可以指定filename参数，该参数是服务器建议浏览器将实体内容保存到文件中的文件名称。 浏览文件提供一个页面浏览文件目录，如果不清楚应该在哪存放文件，可以先输出realpath，再进入目录新建文件夹以及存放部分文件。12345678910111213141516@RequestMapping(&quot;file/show&quot;)public String show(HttpServletRequest request, Model model) &#123; System.out.println(&quot;请求文件查看&quot;); String realpath = request.getServletContext().getRealPath(&quot;&quot;) + &quot;fileUpload\\\\temp\\\\&quot;; File dir = new File(realpath); File files[] = dir.listFiles(); // 获取该目录下的所有文件名 ArrayList&lt;String&gt; fileName = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; files.length; i++) &#123; fileName.add(files[i].getName()); &#125; model.addAttribute(&quot;files&quot;, fileName); return &quot;showDownFiles&quot;;&#125; 浏览文件jsp123456789101112131415161718192021222324&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;c:forEach var=&quot;filename&quot; items=&quot;$&#123;files&#125;&quot;&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/file/down2?filename=$&#123;filename&#125;&quot;&gt;$&#123;filename&#125;&lt;/a&gt; &lt;br /&gt; &lt;/c:forEach&gt; &lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 结果如下： 使用ResponseEntityResponseEntity是一个响应实体，其中包含了返回的头部信息，状态信息以及内容。如下：因此可以将文件解析成二进制流存储进ResponseEntity的body中，同时设置其响应头与状态便可以进行下载。12345678910111213@RequestMapping(&quot;/file/down2&quot;) public ResponseEntity&lt;byte[]&gt; download(@RequestParam String filename, HttpServletRequest request) throws IOException &#123; //通过存放文件目录和文件名获取文件全路径 String filePath = request.getServletContext().getRealPath(&quot;&quot;) + &quot;fileUpload\\\\temp\\\\&quot; + filename; File file = new File(filePath); //定义响应头并设置下载文件报头 HttpHeaders headers = new HttpHeaders(); headers.add(&quot;Content-Type&quot;, &quot;application/x-msdownload&quot;); headers.add(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + URLEncoder.encode(filename, &quot;UTF-8&quot;)); //返回一个响应实体（body，header，status） return new ResponseEntity&lt;byte[]&gt;(FileUtils.readFileToByteArray(file), headers, HttpStatus.OK); &#125; 这里需要注意的是，使用header的setContentType里面，使用的是MediaType类的常量，其中好像并没有找到”application/x-msdownload”类型，经过网络查询发现使用的是：MediaType.APPLICATION_OCTET_STREAM，不过我测试的时候并没有效果（后来发现是status的问题，使用HttpStatus.OK就可以了），因此采用了add手动添加。还有一点就是，使用ResponseEntity，需要一次性将读取出来，如果文件过大可以就会发生OOM异常。如果只有小文件的传输，可以使用ResponseEntity；一旦文件过大，建议采用下面的方式。不过ResponseEntity的好处就在于简洁，只需要获取文件，设置头，然后封装到ResponseEntity返回。 使用Java常规方法Java常规方式，有点类似json响应，服务器接收用户下载文件请求时，获取响应的输出流，加载服务器的文件作为输入流，然后一边从本地输入，一边向客户端传输。这种方式就有效的解决了文件过大会产生OOM异常的问题。同时，如果客户端的连接异常关闭则会抛出异常，可以进行有效的进行捕获进行处理。也可以扩展下载量统计，断点下载（RandomAccessFile）等功能。123456789101112131415161718192021222324252627282930313233343536@RequestMapping(&quot;file/down2&quot;) public String down(@RequestParam String filename, HttpServletRequest request, HttpServletResponse response) &#123; System.out.println(&quot;请求文件下载&quot;); FileInputStream in = null; // 输入流 ServletOutputStream out = null; // 输出流 try &#123; // 获得文件路径 String aFilePath = request.getServletContext().getRealPath(&quot;&quot;) + &quot;fileUpload\\\\temp\\\\&quot;; // 设置下载文件使用的报头 response.setHeader(&quot;Content-Type&quot;, &quot;application/x-msdownload&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + URLEncoder.encode(filename, &quot;utf-8&quot;)); // 读入文件 in = new FileInputStream(aFilePath + &quot;\\\\&quot; + filename); // 得到响应对象的输出流，用于向客户端输出二进制数据 out = response.getOutputStream(); out.flush(); int len = 0; byte b[] = new byte[1024]; while ((len = in.read(b)) != -1 &amp; in != null) &#123; out.write(b, 0, len); &#125; out.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; in.close(); &#125; catch (IOException e1) &#123; &#125; try &#123; out.close(); &#125; catch (IOException e1) &#123; &#125; &#125; return null; &#125;","categories":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/categories/spring/"}],"tags":[{"name":"springmvc","slug":"springmvc","permalink":"http://yoursite.com/tags/springmvc/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"SpringMVC文件上传 原理与实例","slug":"SpringMVCFileUpload","date":"2019-04-08T14:52:18.000Z","updated":"2019-04-08T14:56:00.778Z","comments":true,"path":"2019/04/08/SpringMVCFileUpload/","link":"","permalink":"http://yoursite.com/2019/04/08/SpringMVCFileUpload/","excerpt":"SpringMVC 文件上传 原理与实例SpringMVC除了对数据的封装之外，还对文件组件进行了封装。 流程原理和MultipartResolver接口在DispatcherServlet中定义了一个MultipartResolver属性，如果用户配置了该Bean，启动容器的时候，会自动注入参数，如果用户没有配置，则默认为null。当DispaterServlet收到请求时，它的checkMultipart()方法会调用MultipartResolver的isMultipart()方法判断请求中是否包含了文件且multipartResolver属性存在实例。如果满足条件，则调用MultipartResolver的resolveMultipart()方法对请求数据进行解析，然后将文件数据解析成MultipartFile并封装在MultipartHttpServletRequest对象中返回给DispatcherServlet。","text":"SpringMVC 文件上传 原理与实例SpringMVC除了对数据的封装之外，还对文件组件进行了封装。 流程原理和MultipartResolver接口在DispatcherServlet中定义了一个MultipartResolver属性，如果用户配置了该Bean，启动容器的时候，会自动注入参数，如果用户没有配置，则默认为null。当DispaterServlet收到请求时，它的checkMultipart()方法会调用MultipartResolver的isMultipart()方法判断请求中是否包含了文件且multipartResolver属性存在实例。如果满足条件，则调用MultipartResolver的resolveMultipart()方法对请求数据进行解析，然后将文件数据解析成MultipartFile并封装在MultipartHttpServletRequest对象中返回给DispatcherServlet。 大致流程如下：在MultipartResolver接口中： boolean isMultipart(HttpServletRequest request); // 是否是 multipart MultipartHttpServletRequest resolveMultipart(HttpServletRequest request); // 解析请求 void cleanupMultipart(MultipartHttpServletRequest request); 解析之后的MultipartFile 封装了请求数据中的文件，此时这个文件存储在内存中或临时的磁盘文件中，需要将其转存到一个合适的位置，因为请求结束后临时存储将被清空。 MultipartFile 接口： String getName(); // 获取参数的名称 String getOriginalFilename(); // 获取文件的原名称 String getContentType(); // 文件内容的类型 boolean isEmpty(); // 文件是否为空 long getSize(); // 文件大小 byte[] getBytes(); // 将文件内容以字节数组的形式返回 InputStream getInputStream(); // 将文件内容以输入流的形式返回 void transferTo(File dest); // 将文件内容传输到指定文件中 MultipartResolver 是一个接口，它的实现类如下： CommonsMultipartResolver基于commons-fileupload组件进一步封装，简化了文件上传的代码实现，取消了不同上传组件上的编程差异。因为依赖commons-fileupload组件，所以我们需要导入相关依赖jar包。 实例 导入Maven 依赖 1234567891011&lt;!--文件上传依赖包 --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; 配置文件解析器 123456789101112&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 设定默认编码 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt; &lt;!-- 设定文件上传的最大值为5MB，5*1024*1024 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242880&quot;&gt;&lt;/property&gt; &lt;!-- 设定文件上传时写入内存的最大值，如果小于这个参数不会生成临时文件，默认为10240 --&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;&gt;&lt;/property&gt; &lt;!-- 上传文件的临时路径 --&gt; &lt;property name=&quot;uploadTempDir&quot; value=&quot;fileUpload/temp&quot;&gt;&lt;/property&gt; &lt;!-- 延迟文件解析 --&gt; &lt;property name=&quot;resolveLazily&quot; value=&quot;true&quot;/&gt;&lt;/bean&gt; 编写上传表单 提交方式选择postenctype选择multipart/form-data，表示提交信息中包含文件，使用二进制流提交 1234&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/file/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 控制器处理提交数据12345678910111213141516171819@RequestMapping(&quot;/file/upload&quot;)@Republic String upload(@RequestParam(value = &quot;file&quot;, required = false) MultipartFile file, HttpServletRequest request, HttpSession session) &#123; // 文件不为空 if(!file.isEmpty()) &#123; // 文件存放路径 String path = request.getServletContext().getRealPath(&quot;/&quot;); // 目标文件,使用原文件名 File destFile = new File(path,file.getOriginalFilename()); // 转存文件 try &#123; file.transferTo(destFile); &#125; catch (IllegalStateException | IOException e) &#123; e.printStackTrace(); &#125; &#125; return &quot;success&quot;; //跳转到上传成功页面，新建jsp页面&#125; 源码解析CommonsMultipartResolver 实现了 MultipartResolver 接口，resolveMultipart() 方法如下所示，其中 resolveLazily 是判断是否要延迟解析文件（通过XML可以设置）。当 resolveLazily 为 flase 时，会立即调用 parseRequest() 方法对请求数据进行解析，然后将解析结果封装到 DefaultMultipartHttpServletRequest 中；而当 resolveLazily 为 true 时，会在 DefaultMultipartHttpServletRequest 的 initializeMultipart() 方法调用 parseRequest() 方法对请求数据进行解析，而 initializeMultipart() 方法又是被 getMultipartFiles() 方法调用，即当需要获取文件信息时才会去解析请求数据，这种方式用了懒加载的思想。1234567891011121314151617181920@Overridepublic MultipartHttpServletRequest resolveMultipart(final HttpServletRequest request) throws MultipartException &#123; Assert.notNull(request, &quot;Request must not be null&quot;); if (this.resolveLazily) &#123; //懒加载，当调用DefaultMultipartHttpServletRequest的getMultipartFiles()方法时才解析请求数据 return new DefaultMultipartHttpServletRequest(request) &#123; @Override //当getMultipartFiles()方法被调用时，如果还未解析请求数据，则调用initializeMultipart()方法进行解析 protected void initializeMultipart() &#123; MultipartParsingResult parsingResult = parseRequest(request); setMultipartFiles(parsingResult.getMultipartFiles()); setMultipartParameters(parsingResult.getMultipartParameters()); setMultipartParameterContentTypes(parsingResult.getMultipartParameterContentTypes()); &#125; &#125;; &#125; else &#123; //立即解析请求数据，并将解析结果封装到DefaultMultipartHttpServletRequest对象中 MultipartParsingResult parsingResult = parseRequest(request); return new DefaultMultipartHttpServletRequest(request, parsingResult.getMultipartFiles(), parsingResult.getMultipartParameters(), parsingResult.getMultipartParameterContentTypes()); &#125;&#125; 在上面的代码中可以看到，对请求数据的解析工作是在 parseRequest() 方法中进行的，继续看一下 parseRequest() 方法源码123456789protected MultipartParsingResult parseRequest(HttpServletRequest request) throws MultipartException &#123; // 获取请求的编码类型 String encoding = determineEncoding(request); FileUpload fileUpload = prepareFileUpload(encoding); try &#123; List&lt;FileItem&gt; fileItems = ((ServletFileUpload) fileUpload).parseRequest(request); return parseFileItems(fileItems, encoding); &#125; catch (...) &#123;&#125;&#125; 在 parseRequest() 方法中，首先调用了 prepareFileUpload() 方法来根据编码类型确定一个 FileUpload 实例，然后利用这个 FileUpload 实例解析请求数据后得到文件信息，最后将文件信息解析成 CommonsMultipartFile (实现了 MultipartFile 接口) 并包装在 MultipartParsingResult 对象中。而且从上面解析文件中也可以看到，可以解析出一个List列表，也就是说支持多文件上传，最后附上多文件上传案例。 StandardServletMultipartResolver这个是基于Servlet 3.0来处理 multipart 请求的，但是必须使用支持 Servlet 3.0的容器才可以。 示例 配置文件在spring的配置文件中配置文件解析器用于注入到DispatchServlet12&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot;&gt;&lt;/bean&gt; 因为其是基于servlet所以，其他的参数均在web.xml中配置1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;multipart-config&gt; &lt;!-- 临时文件的目录 --&gt; &lt;location&gt;upload/tem/&lt;/location&gt; &lt;!-- 上传文件最大2M --&gt; &lt;max-file-size&gt;2097152&lt;/max-file-size&gt; &lt;!-- 上传文件整个请求不超过4M --&gt; &lt;max-request-size&gt;4194304&lt;/max-request-size&gt; &lt;/multipart-config&gt;&lt;/servlet&gt; 编写上传表单 1234&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/file/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 控制器处理提交数据 12345678910111213141516171819@RequestMapping(&quot;/file/upload&quot;)public String upload(@RequestParam(value = &quot;file&quot;, required = false) MultipartFile file, HttpServletRequest request, HttpSession session) &#123; // 文件不为空 if(!file.isEmpty()) &#123; // 文件存放路径 String path = request.getServletContext().getRealPath(&quot;/&quot;); // 文件名称 String name = file.getOriginalFilename(); File destFile = new File(path,name); // 转存文件 try &#123; file.transferTo(destFile); &#125; catch (IllegalStateException | IOException e) &#123; e.printStackTrace(); &#125; &#125; return &quot;success&quot;;&#125; 源码分析StandardServletMultipartResolver 实现了 MultipartResolver 接口，resolveMultipart() 方法如下所示，其中 resolveLazily 是判断是否要延迟解析文件（通过XML可以设置）。12345678910public MultipartHttpServletRequest resolveMultipart(HttpServletRequest request) throws MultipartException &#123; return new StandardMultipartHttpServletRequest(request, this.resolveLazily);&#125;public StandardMultipartHttpServletRequest(HttpServletRequest request, boolean lazyParsing) throws MultipartException &#123; super(request); // 判断是否立即解析 if (!lazyParsing) &#123; parseRequest(request); &#125;&#125; 对请求数据的解析工作是在 parseRequest() 方法中进行的，继续看一下 parseRequest() 方法源码1234567891011121314151617181920private void parseRequest(HttpServletRequest request) &#123; try &#123; Collection&lt;Part&gt; parts = request.getParts(); this.multipartParameterNames = new LinkedHashSet&lt;String&gt;(parts.size()); MultiValueMap&lt;String, MultipartFile&gt; files = new LinkedMultiValueMap&lt;String, MultipartFile&gt;(parts.size()); for (Part part : parts) &#123; String disposition = part.getHeader(CONTENT_DISPOSITION); String filename = extractFilename(disposition); if (filename == null) &#123; filename = extractFilenameWithCharset(disposition); &#125; if (filename != null) &#123; files.add(part.getName(), new StandardMultipartFile(part, filename)); &#125; else &#123; this.multipartParameterNames.add(part.getName()); &#125; &#125; setMultipartFiles(files); &#125; catch (Throwable ex) &#123;&#125;&#125; parseRequest() 方法利用了 servlet3.0 的 request.getParts() 方法获取上传文件，并将其封装到 MultipartFile 对象中。 多文件上传续之前CommonsMultipartResolver配置文件 创建多文件页面 123456&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/file/multifile&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 选择文件1:&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br&gt; 选择文件2:&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br&gt; 选择文件3:&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; 控制器处理提交数据 12345678910111213141516171819@RequestMapping(&quot;/file/multifile&quot;) public String multiFileUpload(@ModelAttribute List&lt;MultipartFile&gt; fileList, HttpServletRequest request)&#123; String path = request.getServletContext().getRealPath(&quot;/&quot;); File targetDir = new File(realpath); if(!targetDir.exists())&#123; targetDir.mkdirs(); &#125; for (MultipartFile file: fileList) &#123; File targetFile = new File(realpath,file.getOriginalFilename()); //上传 try &#123; file.transferTo(targetFile); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return &quot;success&quot;; &#125; 其实多文件上次和单文件上传类似，只需把形参列表改成List，在转存的时候，依次遍历就可以了。","categories":[{"name":"learn","slug":"learn","permalink":"http://yoursite.com/categories/learn/"}],"tags":[{"name":"springmvc","slug":"springmvc","permalink":"http://yoursite.com/tags/springmvc/"},{"name":"fileupload","slug":"fileupload","permalink":"http://yoursite.com/tags/fileupload/"}]},{"title":"利用Hexo+Github完成搭建个人博客（2-配置与发布博客）","slug":"create-hexo2","date":"2019-04-06T14:14:14.000Z","updated":"2019-04-06T14:20:59.434Z","comments":true,"path":"2019/04/06/create-hexo2/","link":"","permalink":"http://yoursite.com/2019/04/06/create-hexo2/","excerpt":"寻找模板接上篇，之前已经把博客搭建好了，但是默认的肯定过于单调了些，需要我们进行完善。完善的第一步当然是需要去hexo官方主题找一个中意的模板。里面有很多的主题，点击某个主题之后能进行预览效果。选主题好看是一个方面，另一个是最好有文档教程可以学习配置。不然拿来一个主题，也不能做得酷炫。在预览主题界面一般会有一个GitHub的连接，点击之后会跳转到存放该主题的仓库，里面一般都会有主题的使用教程。我选的是Next主题，Next主题相对来说比较简洁方便，主要是配置教程文档比较详细，在网上也能找到很多相关教程。先来看看GitHub上大佬的示例，然后再确定我们自己的博客应该如何搭配。 Miaia，有Next最近使用教程。uchuhimoAcrisDandy以上几个博客，也说明了Next还提供了不同的布局模板，也就是说，我们选了Next之后，还可以再进行选择。","text":"寻找模板接上篇，之前已经把博客搭建好了，但是默认的肯定过于单调了些，需要我们进行完善。完善的第一步当然是需要去hexo官方主题找一个中意的模板。里面有很多的主题，点击某个主题之后能进行预览效果。选主题好看是一个方面，另一个是最好有文档教程可以学习配置。不然拿来一个主题，也不能做得酷炫。在预览主题界面一般会有一个GitHub的连接，点击之后会跳转到存放该主题的仓库，里面一般都会有主题的使用教程。我选的是Next主题，Next主题相对来说比较简洁方便，主要是配置教程文档比较详细，在网上也能找到很多相关教程。先来看看GitHub上大佬的示例，然后再确定我们自己的博客应该如何搭配。 Miaia，有Next最近使用教程。uchuhimoAcrisDandy以上几个博客，也说明了Next还提供了不同的布局模板，也就是说，我们选了Next之后，还可以再进行选择。 下载主题为了能使用该主题，我们先在存放博客文件的目录下进行Git Bash，将Next下载到本地。 1git clone https://github.com/iissnan/hexo-theme-next themes/next 我们可以看到在themes文件夹下多了一个Next文件夹，这个就是我们下载的主题。下载过来先不急，Hexo和Next为了让用户专注写博客，减小对代码的关注，大多都使用配置进行设置Next主题。所以我们先来了解两个配置文件。 配置站点站点配置文件：位于博客根目录下的 _config.yml，对整个站点的基本内容进行更改。如标题、作者等等。主题配置文件：位于themes\\next下的_config.yml，对当前主题的相关设置。如图标、布局等等。因为它们的文件名是一样的，所以用站点文件和主题文件来区分它们。首先是站点文件配置：hexo官方文档介绍得非常详细，我们就对主要的几个进行简单介绍和配置。# Site 下面:然后继续,或者直接搜索 ‘theme’ ，把字段改成next，表示使用next主题，如果是使用的其他主题的话，就改成其他主题名字：修改之后，重新生成页面和启动服务，默认样式如下：可以看到我们修改的已经生效了，标题和副标题。如果中文显示乱码的话，记事本打开_config.yml，文件 -&gt; 另存为 -&gt; 选择编码 UTF-8 -&gt; 确定（默认是相同目录，替换就ok） 配置主题站点先暂时配置到这，其他的后面有需要再配置。下面进行主题配置。打开\\themes\\next下的_config.yml文件。其实如果英语比较好的话，里面注释都讲的比较详细了，一直往下设置就ok。不过英语不好的我，只能参考Next文档进行配置。 首先配置整个网站的主题布局等等，就按照Next使用文档的配置顺序来配置一下。 选择主题[Scheme]这个主题是Next的外观，我们可以在主题文件里面搜索 “scheme:”来找到设置位置：这个配置还有一个好处就是：支持动态设定，也就是修改了配置之后不需要重新生成静态文件，开启服务。在之前预览的页面直接刷新就可以了。刷新以后主题外观就改变了。 设置菜单所谓菜单就提供一个按钮，点击之后跳转到不同的地方。菜单设置就刚刚外观设置的上面一个，找不到可以进行搜索”menu“，找到相关字段：Next默认是只有home 和 archives。其他的菜单都被注释了，我们就把需要展示的菜单注释去掉，然后保存并刷新我们的预览页面。就可以看到以下效果了：在这里值得我们注意的是，菜单的设置格式 ，如：” tags: /tags/ || tags “ ； 好在配置文件里面也提供了注释，大致就是说，”名称:链接 || 图标“ 。所谓的名称并不会直接展示在网页上，而是会去\\next\\languages目录下，找到刚刚站点设置的语言文件，在里面进行查找匹配。所以我们在配置文件中写的是英文，但是我们网页展示的却是汉子。如果改成其他语言，自然也会替换成其他语言的文字展示。然后 || 之后的图标，Next会自动到FontAwesome上进行匹配。有兴趣的可以查看自己博客网页的源代码，图标就是使用的fa fa-*格式。在菜单这里还有一点就是，目前我们只能看这个菜单，如果点击的话，会出现404错误 或者是 Cannot GET /*/，这是因为我们本地没有相关的页面提供给它。 那我们就需要新建页面提供给主题进行访问。回到存放博客的根目录下，进行git bash（以标签为例）： 1hexo new page tags 之后我们会发现在博客根路径的source文件夹里面多了一个tags文件夹，我们继续打开就能发现一个index.md文件 ，然后需要编辑这个md文件，来让Next来识别它。我们需要添加一个type字段，添加tags (这个是对应了之前menu设置名称，点击tags菜单就能跳到这个页面)。然后我们重新生成，启动预览就可以点击菜单并且进去了。其他菜单同理。 设置侧边栏所谓侧边栏也就是我们展示我们刚刚菜单的那一栏，在配置文件中搜索Sidebar Settings，就可以看到相关设置。侧边栏可以展示的东西还挺多的，这里我们按照配置文件从上到下进行设置：1.社交链接（Social Links），用于展示其他的社交平。我们先把social的注释去掉，然后把需要展示的选项注释也去掉，在这里的设定格式和之前菜单是一样的，然后我们也可以添加自定义的社交连接。后面也有关于图标的设置，如果上面设置了图标，下面就不用添加了。设置一下是否显示图标和仅显示图标就ok。效果显示： 2.友情连接（Blog rolls），这个功能就不多介绍了，主要看怎么配置吧。效果如下： 3.设置头像（Sidebar Avatar）设置头像有三种方式： 将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在）配置为：avatar: /uploads/文件名 或者 放置在 source/images/ 目录，配置为：avatar: /images/文件名 还有就是直接使用网络连接，配置为：avatar: http://example.com/avatar.png 4.其他还有几个设定不是非常重要，但是也可以设置一下，不然就用默认的都可以。 设置文章内目录 12toc: enable: true 设置侧边栏展示在哪边 12position: left#position: right 侧边栏何时展示 1234#display: post #默认，存在目录列表显示display: always #在所有页面都显示#display: hide #在所有页面都隐藏，需要手动展开#display: remove #完全移除 添加一个内容已经查看的百分比，这个挺有意思的 1scrollpercent: true 第三方服务 网站访问统计，我们采用不蒜子提供的服务。进入不蒜子网页，有手动设置方式。不过现在Next配置文件，已经集成了。手动配置可以更加个性化一点。配置文件就比较方便。直接在配置文件中搜索busuanzi_count ，将下面的enable改成true就可以了。 1enable: true 文章阅读统计，在文件中搜索leancloud_visitors，使用LeanCloud帮助我们统计。先进入LeanCloud进行注册验证，然后新建应用，获取key 和id。随后将其填入我们的配置文件。 1234leancloud_visitors: enable: true app_id: app_key: 更多功能我的博客暂时配置到这里就差不多了（主要是东西挺多的，有点麻烦）。有需要更多炫酷功能可以进行百度查找，其他相关设置。如https://www.jianshu.com/p/f054333ac9e6https://www.jianshu.com/p/3a05351a37dc 新建博文前面的工作做了那么多，当然不仅仅是就搭建一个网站算了，书写博客才是我们的最终目的。在博客根目录下git bash ： 1hexo new title # title 文章标题 然后会提示: Created: D:\\CODE\\bolg2\\source_posts\\title.md 那就说明已经新建了一个新文章，然后照着这个目录找到刚刚新建的文件，打开之后会发现只有这一部分。官方文档称之为Front-matter，用于指定个别文件的变量。在这一部分，预先定义的内容有 layout 布局 title 标题 date 建立日期 updated 更新日期 comments 开启文章的评论功能 true/false tags 标签 categories 分类 permalink 覆盖网站网址一般就设定标题、标签、分类、时间就可以了，标题和时间hexo会自动帮我们加上，所以我们就手动添加标签和分类上去。 123456789---title: testdate: 2019-04-06 20:45:51tags:- Blog- Hexocategories:- learn,hexo --- 这里需要注意的是标签和分类的写法。然后还有分类只支持单分类，也就是说，如果你在分类下面写上两个，会用最后的一份分类指定给文章。不过分类虽然不支持平级，但是可以有从属，也就是父子级分类，使用,分割分类的层次关系。 高级编辑Hexo的博文使用MarkDown语法，多少会受到限制。为了弥补标签的不足，Hexo提供了标签插件来支持博文的多样化。大致分为以下几类 引用块，在文章中插入引言，可包含作者、来源和标题。语法如下： 123&#123;% blockquote [作者, 来源] [链接] [链接标题] %&#125;content&#123;% endblockquote %&#125; []中的为可选项，如引用歌词： 123456&#123;% blockquote [陈宏宇, 早春的树] %&#125;臂弯做衣架摇晃在庭前腰杆做长椅你轻靠,或躺下看书&#123;% endblockquote %&#125; 臂弯做衣架摇晃在庭前腰杆做长椅你轻靠,或躺下看书 [陈宏宇早春的树] 代码块，相对使用反引号而言更加具体描述的引用。 123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 如： 1234&#123;% codeblock [Thread] [lang:Java] [http://tool.oschina.net/apidocs/apidoc?api=jdk-zh] [java jdk] %&#125;PrimeThread p = new PrimeThread(143);p.start();&#123;% endcodeblock %&#125; [Thread] [] [http://tool.oschina.net/apidocs/apidoc?api=jdk-zh] [java jdk]12PrimeThread p = new PrimeThread(143);p.start(); 引用外部资源（图片、视频）图片： 1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; 视频： 12&#123;% youtube video_id %&#125; #插入youtube视频&#123;% vimeo video_id %&#125; #插入vimeo视频 资源文件（添加本地图片）统一管理适合只有少量图片或者需要重复使用的图片。放在主题source/images 文件夹中，通过![](/images/image.jpg)的方法来访问他们。 分散管理适用于每篇博文使用的不同的图片，更加组织化的方式来管理资源。可以非常方便的管理每篇博文的资源。 首先修改站点配置文件，找到post_asset_folder ，设置为true 1post_asset_folder: true 当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径仅输入文件名来引用它们，这样你就得到了一个更简单而且方便得多的工作流。 相对路径引用的标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法![](/example.jpg) ，它将不会出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是 markdown ：通过这种方式，图片将会同时出现在文章和主页以及归档页中。","categories":[{"name":"learn","slug":"learn","permalink":"http://yoursite.com/categories/learn/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"利用Hexo+Github完成搭建个人博客（1-搭建）","slug":"create-hexo1","date":"2019-04-06T14:03:18.000Z","updated":"2019-04-06T14:21:29.639Z","comments":true,"path":"2019/04/06/create-hexo1/","link":"","permalink":"http://yoursite.com/2019/04/06/create-hexo1/","excerpt":"前言​ 最近在学java框架，想利用博客记录下来学习过程以及学习成果，同时也算为自己做一个笔记，平时都是使用Xmind思维导图做笔记，但是在手机上不太方便回顾。本来是打算自己用java写一个博客系统出来，一来记录自己的学习路程，二来可以作为毕业设计，不过考虑到打算重构之前的在线购物系统，以及水平能力有限，便放弃了这个想法。好在无意中接触了hexo，首先hexo的风格吸引了我，画面简洁。其次是功能强大，基本上该有的功能都有。再加上正在学习使用MarkDown书写工具，以及接触GitHub，可以说是各种机缘巧合。正好进行一个系统的全面的学习。​ 我分别在不同的电脑上搭建了两次博客，第一次是笔记本（win10），可以说是磕磕碰碰，最后勉勉强强算搭上了。第二次是在第一次记录的基础上，使用腾讯云服务器（win server 2012）进行搭建，整个过程都非常顺利，这个博客便是第二次搭配记录。跟着这个步骤，最多30分钟便能搭起一个基础的博客。不过基础的博客肯定不能满足后续的要求。 ​ 在下一篇学习页面设置和写/发博客。提前预览​ 建议搭配目录阅读","text":"前言​ 最近在学java框架，想利用博客记录下来学习过程以及学习成果，同时也算为自己做一个笔记，平时都是使用Xmind思维导图做笔记，但是在手机上不太方便回顾。本来是打算自己用java写一个博客系统出来，一来记录自己的学习路程，二来可以作为毕业设计，不过考虑到打算重构之前的在线购物系统，以及水平能力有限，便放弃了这个想法。好在无意中接触了hexo，首先hexo的风格吸引了我，画面简洁。其次是功能强大，基本上该有的功能都有。再加上正在学习使用MarkDown书写工具，以及接触GitHub，可以说是各种机缘巧合。正好进行一个系统的全面的学习。​ 我分别在不同的电脑上搭建了两次博客，第一次是笔记本（win10），可以说是磕磕碰碰，最后勉勉强强算搭上了。第二次是在第一次记录的基础上，使用腾讯云服务器（win server 2012）进行搭建，整个过程都非常顺利，这个博客便是第二次搭配记录。跟着这个步骤，最多30分钟便能搭起一个基础的博客。不过基础的博客肯定不能满足后续的要求。 ​ 在下一篇学习页面设置和写/发博客。提前预览​ 建议搭配目录阅读 1.概述​ Hexo官网：A fast, simple &amp; powerful blog framework,即:快速、简洁且高效的博客框架。基于Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染，只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站，Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。​ 也就是说，只需要30分钟左右就可以搭建一个属于自己的个人博客。同时又有丰富的插件可以使你尽可能的完善自己的博客细节。利用GitHub的git pages，可以托管我们的静态网页，而且可以自定义域名（参考中有）。等博客搭建完毕，我们就只需要写博客内容了。 2.搭建环境2.1 Node.js&emsp; &emsp; 一个JavaScript运行环境,我们使用它来生成我们博客的静态页面。如果不确定自己电脑上是否安装了Node.js,可以在cmd命令行下运行1npm -v ​ 运行结果如下表示未安装： ​ ​ 接下来我们需要去官网下载，进行安装。同时如果版本过低可能会导致部分功能丢失或者配置方法不同，建议6.0以上。​ ​ 安装完成之后我们再运行cmd命令会显示如下结果​ ​ 如果还是提示非命令，有可能是node没有加到环境变量中去，在环境变量的path中，加上刚刚的安装目录。（如我的安装目录：C:\\Program Files\\nodejs\\）有自定义目录需要修改成自定义目录。 2.2 Git 环境​ 接着我们就是需要安装Git了，同时我们先查看一下电脑是否安装了git，在cmd中执行 1git --version ​ 如果显示为非命令，则需要我们下载安装，可以上官网，如果下载较慢的话，也可以上某度云进行下载，安装过程基本上选择默认的就好了。建议版本2.0以上​ 验证是否安装成功同上，不过这次需要加的环境变量则是Git安装目录下的cmd，（如我的：C:\\Program Files\\Git\\cmd） 2.3 Git hub&emsp;&emsp;Git-hub,注册过程就不多赘述，基本上不会有什么问题。重要的是需要建立存放代码的仓库和添加SSHkey保证本地能正常上传代码到github。 1）建立仓库：登陆GitHub之后，在点击右上角的“+”号，选择 new repository。​ 在 Repository name中填入”用户名.github.io”。用户名就是GitHub的用户名。​ 最后点击create repository 这一步就ok了。​ 2）第二步，我们来添加SSHkey,确保我们本地有权限能够提交代码到github。首先我们仍然测试看看本地能否存在key（第一次当然是没有，不过为了和后面出现对比，我们可以先测试一下）。首先在桌面右击 -&gt; 选择Git Bash Here调出git命令台。输入下面命令： bash1ssh -T git@github.com 如果提示&lt; Are you sure you want to continue connecting (yes/no)?&gt;，输入yes ​ 这就是本地没有权限连接的，需要我们创建SSHkey。我们继续输入以下命令 bash1ssh-keygen -t rsa -C &quot;注册github的邮箱&quot; ​ 三次回车之后，会出项下面的结果：​ 然后git会自动在c盘用户下面的当前用户文件夹新建一个.ssh文件，里面有一个 id_rsa.pub 文件。使用记事本打开之后，复制里面的内容。​ 我们在本地生成好key之后，需要添加到github上。在GitHub网页进入个人设置选择SSH and GPG keys，新建一个ssh key：​ 把复制过来的内容粘贴在key框，上面的title可以写，也可以不写，不写会默认使用邮箱。如果为了区分多台客户端，可以填写区分一下。​ 保存之后，输入密码确认，跳转到sshkey页面，你会发现刚刚添加的key已经在里面了。到这里我们就已经添加成功了，于是我们再测试一下连接，出现以下结果就是正确的。 ​ 然后再运行以下命令，来让git记录我们的身份bash12git config --global user.name &quot;GitHub账号&quot;git config --global user.email &quot;注册邮箱&quot; ​ 到这里我们的准备工作就已经结束了。下面就开始搭建博客，如果到这里就放弃，那就前功尽弃了（加油）。 3.搭建博客3.1 安装hexo​ git bash 执行以下代码：bash1npm install -g hexo 可能会要一点时间，如果没有报错(ERR)，说明安装问题。 3.2搭建博客新建一个文件夹，用来存放我们的博客文件。右键 -&gt;git bash，依次运行以下代码。‘#’后面是注释 bash123hexo init #初始化hexo环境hexo g #生成静态页面hexo s #开启本地服务 执行完最后一条命令，会出现如上结果。从图中我们也得知，在浏览器输入&lt; http://localhost:4000/ &gt; 就可以浏览我们的博客了，然后按ctrl + c 结束本地服务。生成的静态文件就在public文件夹中。 至此我们就快大功告成，把代码同步到github让它帮我们管理代码。同时，我们也可以输入之前我们定义的仓库名，进行外网访问。不过，我们还要进行最后一步配置。 3.3配置并同步代码用文本文件打开刚刚存放博客文件的目录中的 `_config.yml` 文件，然后拉到最后找到deploy: 按照如下进行配置，冒号后面一定要跟空格： 1234deploy: type: git repository: git@github.com:GitHub用户名/GitHub用户名.github.io.git branch: master ​ GitHub用户名就是刚刚新建仓库的名称。保存之后，再依次运行以下命令： bash12npm install hexo-deployer-git --save #安装插件hexo d #上传代码 上传成功之后，然后我们可以到我们GitHub的仓库下看看，是不是把本地的文件上传过去了。然后我们利用其它的浏览器，或者客户端输入 刚刚定义的仓库名称 &lt; https://licqing.github.io/ &gt;就可以访问你的博客了。 ​ 搭建博客的结束，正是入门博客的开始。hexo文档。后续将配置博客样式和书写博客。 4.途中遇见的问题说说第一次搭配遇到的问题和最后怎么解决的吧。 hexo init 命令 ： 错误 conmand not found 。应该是hexo未配置进环境变量，我们找到node_modules文件夹,这时我们发现里面有很多文件夹，找到hexo文件夹,这里我们可以看到一个bin文件夹，进到bin。然后把这个目录加到环境变量path中去。 hexo init 命令 ： 错误 FATAL not empty。存放博客的地方一定是需要空文件夹。注意检查空文件夹。 hexo g 命令 ： 错误 FATAL bad indentation of a mapping entry at line 82, column 13。 _config.yml文件冒号后面没有跟空格 5.参考（可配置域名） https://www.jianshu.com/p/05289a4bc8b2 https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html https://hexo.io/zh-cn/docs/writing","categories":[{"name":"learn","slug":"learn","permalink":"http://yoursite.com/categories/learn/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-04-03T15:05:48.930Z","updated":"2019-04-03T15:05:48.931Z","comments":true,"path":"2019/04/03/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}