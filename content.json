{"meta":{"title":"L","subtitle":"栗子树上苹果花","description":"废宅一个","author":"Li","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2019-04-04T09:42:39.000Z","updated":"2019-04-05T07:25:53.652Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"有关于你"},{"title":"我的标签","date":"2019-04-06T09:29:58.000Z","updated":"2019-04-06T09:34:41.626Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-04-04T09:42:00.000Z","updated":"2019-04-04T10:01:10.759Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"【Linux】CentOS7 下安装Docker 和运行Jar包","slug":"installdocker","date":"2020-02-15T09:41:27.000Z","updated":"2020-02-15T12:37:50.985Z","comments":true,"path":"2020/02/15/installdocker/","link":"","permalink":"http://yoursite.com/2020/02/15/installdocker/","excerpt":"","text":"【Linux】CentOS7 下安装Docker 和运行Jar包1.简介1.1 是什么？简单来说就是一个轻量型的虚拟机，与虚拟机不同的是Docker容器实现的是软件资源上的虚拟化。而虚拟机是将硬件也进行虚拟化，因此容器比较轻量级，节约资源。 1.2 可以做什么？ 1)Web 应用的自动化打包和发布。2)自动化测试和持续集成、发布。3）在服务型环境中部署和调整数据库或其他的后台应用。4）从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。—–来自菜鸟教程 目前我仅用于web应用部署，希望之后可以有机会进行其他的应用。 1.3 怎么做？看下面 2.安装和配置2.1 安装docker安装所需的软件包1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 安装成功的话，会有以下输出。1xxx already installed and latest version 配置docker的国内镜像源1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新缓存1sudo yum makecache fast 安装docker-ce1sudo yum -y install docker-ce 启动dokcer1sudo systemctl start docker 测试运行 hello-world:1docker run hello-world #很慢 2.1 配置dockerdocker默认的镜像源于国内而言是有些慢，所以可以配置一下国内的镜像源，提高一下pull速度。创建目录1sudo mkdir -p /etc/docker 创建一个镜像配置文件1sudo vim /etc/docker/daemon.json 配置文件中添加镜像123&#123; \"registry-mirrors\":[\"http://hub-mirror.c.163.com\"] &#125; 重启docker1systemctl restart docker 一些其他的加速站点 123https://registry.docker-cn.comhttp://hub-mirror.c.163.comhttps://mirror.ccs.tencentyun.com 3.基础使用3.1 Docker 安装Redis1docker pull redis:latest 查看当前的镜像1docker images 运行redis123456docker run -d --name redis-test -p 6379:6379 redis#-d : 后台运行#--name : 指定容器的名称#redis-test : 容器名称#-p : 指定端口映射，前面的是容器的端口，后面的是系统的端口#redis : 镜像名称 查看当前运行中的容器1docker ps 3.2 Docker 基本概念和命令 镜像：运行软件模板，如之前的redis 容器：镜像运行之后的实例，如之前的 redis-test 命令： docker images：查看本地docker镜像列表 docker ps : 查看当前运行中的容器实例，可以检查镜像是否运行成功 docker rm id：删除指定容器 docker rmi imges-name：删除指定镜像","categories":[],"tags":[]},{"title":"CentOS7 下 安装JDK与Maven","slug":"installjdkandmaven","date":"2020-02-14T14:32:01.000Z","updated":"2020-02-14T14:42:11.934Z","comments":true,"path":"2020/02/14/installjdkandmaven/","link":"","permalink":"http://yoursite.com/2020/02/14/installjdkandmaven/","excerpt":"","text":"[TOC] CentOS7 下 安装JDK与Maven1.获取压缩包Maven与Jenkins都需要jdk，所以先安装jdk，同时maven与jdk安装步骤大致相同，可以同时操作1.使用ftp传输JDK安装包到linux上 某云下载提取码：hm6u 2.wget方式获取 以下是jdk的 1wget --no-cookies --no-check-certificate --header \"Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie\" \"http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.tar.gz\" 2.解压1.使用tar -zxvf 解压jdk与maven的压缩文件 。输入命令之后，再输入文件名的前面几个字母可以按tab补全；分别解压之后会产生两个文件夹。 使用mv命令移动这两个文件夹到指定目录,方便后续配置 123mv apache-maven-3.6.3 /usr/local/mavenmv jdk1.8.0_221 /usr/local/jdk8 移动完成之后，可以分别进入查看是否移动了正确的文件 3. 配置环境变量1vim /etc/profile 在文件的最后添加上123export JAVA_HOME=/usr/local/jdk8 # 刚刚jdk移动到的目录export MAVEN_HOME=/usr/local/maven # 刚刚maven移动到的目录export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$MAVEN_HOME/bin:$PATH 最后使用以下命令使配置生效 1source /etc/profile 最后检查是否生效 123java -version #检查jdk是否安装成功mvn -v #检查maven是否安装成功 maven成功 4.问题一开始运行java -version的时候报错如下 12[root@instance-7k1d5qb8 bin]# java -version-bash: /usr/local/maven/bin/java: /lib/ld-linux.so.2: bad ELF interpreter: No such file or directory 度娘了一圈，大意是由于系统位数差异，缺少了东西。找到如下解决方法 1yum install glibc.i686 5. 总结1.安装流程如下：获取压缩包-》解压指定文件位置-》配置环境变量-》刷新环境变量 2.还有一种安装方法是通过yum源来安装，相当于在windows下的自动安装，如果不熟悉不太方便掌握文件位置 3.本篇基于百度云服务器纯净的Centos版本，为后续Jenkins安装部署做铺垫","categories":[],"tags":[]},{"title":"【Linux】使用Jenkins和Docker集成部署SpringBoot应用","slug":"runjenkins","date":"2020-02-14T07:43:41.000Z","updated":"2020-02-18T06:53:03.867Z","comments":true,"path":"2020/02/14/runjenkins/","link":"","permalink":"http://yoursite.com/2020/02/14/runjenkins/","excerpt":"","text":"[TOC] 一、Jenkins介绍来自官网 的介绍： 作为一个可扩展的自动化服务器，Jenkins 可以用作简单的 CI 服务器，或者变成任何项目的持续交付中心。 我的理解： 可以将代码从SVN或GIT仓库拉取过来进行自动编译与发布，所以可以成为一个交付中心，也可以作为一个集成测试环境。 二、前置准备2.1服务器(Linux)所需环境1234567OS：CentOS7 （买的百度云学生服务器JenkinsDockerJdkMavenSVNGit(从github拉取代码所需) Jdk&amp;Maven安装点这Docker 安装点这SVN 安装使用点这 2.2配置Docker工作空间12345#创建文件夹用来放docker工作空间mkdir /home/work/democd /home/work/demo#创建备份文件夹mkdir backup 然后添加Docker构造文件1vim Dockerfile 在文件中添加如下内容1234567#基于openjdk:8FROM openjdk:8#这里其他的项目，可以把demo改成其他的项目名称ADD demo-1.0-SNAPSHOT.jar demo.jarRUN bash -c &apos;touch /demo.jar&apos;ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/demo.jar&quot;] 添加shell脚本文件 1vim run.sh 添加如下内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#定义好这些变量，后面其他的项目，只需要改前面这些变量即可PROJECT_NAME=JenkinsDemo #Maven项目名称IMAGE_NAME=demo #生成的镜像名称BASE_PATH=/home/work/demo #Docker工作空间PORT=9120 #端口TASK_NAME=Jenkins # 任务名称SOURCE_PATH=/var/lib/jenkins/workspace/$TASK_NAME/target/ # Jenkins生成jar包位置#查看当前docker是否运行了该项目CID=$(docker ps | grep \"$IMAGE_NAME\" | awk '&#123;print $1&#125;') DATE=`date +%Y%m%d%H%M` # 将jar包移动到工作空间function transfer()&#123; echo \"newest $SOURCE_PATH/$PROJECT_NAME-1.0-SNAPSHOT.jar moveto $BASE_PATH ....\" sudo cp $SOURCE_PATH/$PROJECT_NAME-1.0-SNAPSHOT.jar $BASE_PATH/$IMAGE_NAME-1.0-SNAPSHOT.jar echo \"move complete\"&#125; # 备份function backup()&#123; if [ -f \"$BASE_PATH/$PROJECT_NAME-1.0-SNAPSHOT.jar\" ]; then echo \"$PROJECT_NAME-1.0-SNAPSHOT.jar 开始备份\" sudo cp $BASE_PATH/$PROJECT_NAME-1.0-SNAPSHOT.jar $BASE_PATH/backup/$PROJECT_NAME-$DATE.jar sleep 3 sudo rm -rf $BASE_PATH/$PROJECT_NAME-1.0-SNAPSHOT.jar echo \"备份完成\" else echo \"$BASE_PATH/$PROJECT_NAME-1.0-SNAPSHOT.jar not exists , pass \" fi&#125; #构建镜像function build()&#123; echo \"开始构建\" cd $BASE_PATH sudo docker build -t $IMAGE_NAME .&#125; #运行function run()&#123; backup transfer build if [ -n \"$CID\" ]; then echo \"存在，删除再运行\" sudo docker stop $CID sudo docker rm $CID sudo docker run -d -p $PORT:$PORT $IMAGE_NAME echo \"complete\" else echo \"不存在，直接运行\" sudo docker run -d -p $PORT:$PORT $IMAGE_NAME echo \"create ok\" fi&#125; #执行run方法run 三、 安装Jenkins3.1 官网安装步骤如下：12345678#添加jenkins 源sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo#导入keysudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key#安装yum install jenkins 不过通过yum安装的效果会比较慢，极端前端下仅几k的速度，因此可以把rpm包先下过来，然后通过rpm的方式安装 3.2 rpm方式安装如下： 首先下载rpm包，可从清华镜像下载,也可以从某云提取码w6tl下载 将rpm包上传至centos 中 执行rpm -ivh jenkins-2.204.2-1.1.noarch.rpm 这个文件 3.3 启动jenkins1service jenkins start 如果是自己安装的jdk，Jenkins第一次启动可能会报错，可以使用命令systemctl status jenkins.server来查看错误明细，可以看到错误信息提示java: no such file or directory 执行如下命令：vim /etc/init.d/jenkins 在candidates里面加上自己安装的jdk的java命令的位置，如下 然后重新加载配置文件systemctl daemon-reload后重启Jenkins 1service jenkins start 成功执行有如下提示 12[root@instance-7k1d5qb8 ~]# service jenkins start Starting jenkins (via systemctl): [ OK ] 四、 访问Jenkins在浏览器打开地址http://服务器ip:8080 ，不出意外就能进入到如下界面，然后根据提示输入密码： 输入密码之后会进入到如下界面，选择推荐的插件即可，就会进入到插件安装页面。 如若网络不好的情况下，可能会出现如下情况，安装插件失败 解决方法（1）如下 打开 http://ip:8080/pluginManager/advanced 最后站点设置 https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 然后保存 解决方法（2）如下 1vim /var/lib/jenkins/hudson.model.UpdateCenter.xml 将 https://updates.jenkins.io/update-center.json&quot; 修改为 “http://mirror.xmission.com/jenkins/updates/update-center.json&quot; 然后systemctl daemon-reload 使配置生效，并重启Jenkins systemctl restart jenkins 访问Jenkins出现的问题： 可能是由于自己按照的jdk，少了一些基础程序，如下安装，重启即可： 1sudo yum install libgcc.i686 --setopt=protected_multilib=false 五、配置Jenkins插件安装成功之后会进入到如下界面，创建一个用户即可 使用账号密码登陆之后需要进行一些基础配置： 选择全局工具配置此处主要配置maven、jdk、docker 三者配置相似，把自动安装的勾取消，便可以输入在系统中的位置。查看环境变量中位置如下： 而yum所安装的docker 位置如下： 1/var/lib/docker 六、创建SpringBoot项目新建一个maven项目，项目名为JenkinsDemo 项目名在后续会用到 pom依赖和插件如下123456789101112131415161718192021222324252627282930313233343536373839404142&lt;parent&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt;&lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; application.yml 修改端口，默认8080会和Jenkins冲突，除非修改了Jenkins的端口12server: port: 9120 Controller类123456789@RestControllerpublic class HelloController &#123; @RequestMapping(\"/test\") public String hello()&#123; return \"自动构建测试\" + LocalDateTime.now(); &#125;&#125; 启动类123456@SpringBootApplicationpublic class Main &#123; public static void main(String[] args) &#123; SpringApplication.run(Main.class,args); &#125;&#125; 项目基础结构搭建完成之后。 6.1 添加SVN控制 添加完版本控制之后，底端会有一个Version Control ，右键选择commit 勾选需要提交的文件夹或文件 提交完成之后，可以在svn管理软件中看到，此处使用小乌龟 七、新建任务输入名称Jenkins，选择构建一个自由风格的软件项目 确定，便进入到如下配置勾选这个，以免产生过多的文件，导致服务器资源耗竭添加svn，Jenkins会从这获取源码svn当然需要添加账号密码触发器，大概就是何时会进行构建，如若是变化不频繁的，可以不选，手动构建这里仍然是删除之前的工作空间，避免代码冲突因为我们的是Maven项目，所以选择Maven构建Maven构建配置如上。配置文件也可以指定位置，最好指定修改了国内镜像的settings.xml 文件后面选择执行shell脚本 1234#!/bin/bashcd /home/work/demosudo ./run.sh 最后确定 7.1 构建查看输出项目构建成功首页如下所示，点击名称Jenkins查看该任务详情 里面的工作空间存放了从svn拉取的代码，下面的Build History 就是每次构建的记录 这里是看工作空间的代码 点击Build History里面的某一项记录，可以进入到这里，然后点击控制台输出可以查看代码运行情况。 第一次运行输出往往会需要从maven下载各种依赖，如果比较慢的话，是否需要切换为国内镜像。 下图的红圈中， 第一部分表示Maven install 已经ok了 ； 第二部分是开始执行shell命令 ； 第三部分是执行Dockerfile 命令。 如果在那个部分出了问题导致访问失败，可以对应排除。 如果一路顺利，⑧出意外的话，执行 1docker ps 便可以看到如下输出，表示该demo已经运行完成。 然后我们只需要在浏览器输入 1http://ip:9120/test 便可以看到如下输出。然事与愿违，这个过程构建了好几次才搞定。后面有参考 7.2 构建遇见的问题 sudo: ./run.sh: command not found ，因为刚刚创建的run.sh文件没有赋予可执行权限 ​ 在/home/work/demo 目录下执行如下命令 1chmod a+x run.sh 各种no such directory , 根据控制台输出提示的部分，然后查看是哪个文件配置出错，然后处理 sudo: no tty present and no askpass program specified 因为在shell文件中有sudo命令，但是权限又不够。 12345678910#在Jenkins宿主服务器上运行如下命令$ sudo visudo#在文件的末尾加上一行jenkins ALL=(ALL) NOPASSWD: ALL#保存文件（注意保存的时候修改文件名，文件名后缀不要加上默认的.tmp，即可覆盖原文件）Ctrl+O#退出编辑Ctrl+X#重启Jenkins服务/etc/init.d/jenkins restart Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? ​ 重启docker 即可 systemctl restart docker 八、更新迭代在Controller中添加如下代码： 1234@GetMapping(\"/new\") public String newMethod()&#123; return \"version 2\";&#125; 然后提交到svn 稍等一会待Jenkins自动构建 然后在浏览器地址中输入http://ip:9120/new,不出意外便能出现一下结果。如果无： 查看是否产生了构建，若无，点击立即构建手动 查看构建记录中的控制台输出，根据不同的提示，解决不同的问题。 九、总结这仅是Jenkins的简单使用，还有更过的高级用法暂未用到，学习记录倒是够了。 1.这里用Jenkins做了什么？ ​ 本地敲代码 -》 提交到SVN -》 Jenkins自动编译部署 -》访问网页 2.Jenkins几个配置 ​ 全局配置: Jdk、Maven、Docker ​ 任务配置: 代码源，如何构建","categories":[],"tags":[]},{"title":"【Python】如何监控Python爬虫进程，实现异常重启或异常通知？","slug":"python-clawer-restart","date":"2020-01-11T08:25:22.000Z","updated":"2020-01-11T08:27:28.528Z","comments":true,"path":"2020/01/11/python-clawer-restart/","link":"","permalink":"http://yoursite.com/2020/01/11/python-clawer-restart/","excerpt":"","text":"1.项目环境基于 Python3.7 ，使用 Scrapy框架，正常抓取某网站搜索指数排名。 2.需求背景由于网络时好时坏，有时候会遇到timeout这种延时错误，出错之后爬虫便会停止，如果没有第一时间重启，或者是排错，抓取效率便会十分低下。所以便想着有没有解决方法（爬虫项目是同事写的，跑在我电脑上，实习生打杂就完事了 3.解决思路 1.利用另外一个Python程序，监控该爬虫进程是否正常进行，同理也可以扩展到监控其他的程序是否正常运行。 2.利用Scrapy框架自身提供的中间件进行错误处理 3.1 进程监控 实现进程监控需要解决以下问题 如何用python获取电脑中运行的进程？ 如何知道要监控的进程是否存活？ 第一个问题使用python提供的os库可以解决 1os.popen('tasklist') tasklist ： 输出电脑上当前所执行的程序名已经进程编号PID 该方法类似与在cmd命令行下所执行的效果一样，会将在cmd下执行的结果输出到缓冲流，因此我们也需要从缓冲流中把结果读出来。 1os.popen('tasklist').read() 第二个问题，我们可以使用新建子进程来解决这个问题 12345678910from multiprocessing import Processfrom scrapy import cmdlinedef execute_spider() cmdline.execute('scrapy crawl my_spider'.split())my_pro = Process(target=executeSpider)my_pro.start()print(\"pid:%s =\" % my_pro.getpid())# 在这里可以获得pid,可以使用进程通信方式把pid传递过去，我比较简单，使用的文件存储pid，监控程序读文件就好了 在这里使用getpid()便可以获得该爬虫的进程号，结合之前的命令，便可以知道当前程序是否正常运行。 12# 从tasklist的输出中，统计该pid的数量，从而判定该进程是否存在 isAlive = os.popen('tasklist').read().count(pid) != 0 3.2 Scrapy中间件之异常处理在Scrapy中存在两种中间件，一种是SpiderMiddleWare（蜘蛛中间件），一种是DownloaderMiddlerWare（下载器中间件）。 蜘蛛中间件： Scrapy中Engine组件与Spider交互经过的中间件，如果蜘蛛发生的异常，就在这个里面处理，比如在解析数据的时候发生的错误。对应的方法如下： 12345678 \"\"\"response: 异常被抛出时被处理的response对象 exception: 抛出的异常 spider: 抛出该异常的spider对象 \"\"\" def process_spider_exception(self, response, exception, spider): # 相应处理 pass 下载器中间件：Scrapy中Engine组件与Downloader交互经过的中间件，这个处理的错误一般都是网络问题，或者服务器问题。与自己敲的蜘蛛代码关系不大。（我选的这个12345678\"\"\" request: 产生异常的request对象 exception: 抛出的异常对象 spider: 产生异常的request对象的spider对象 \"\"\" def process_exception(self, request, exception, spider): # 相应处理 pass 如果使用中间件，别忘记在setting.py文件中开启中间件 123DOWNLOADER_MIDDLEWARES = &#123; 'MySpider.middlewares.MyDownloaderMiddleware': 543,&#125; or 蜘蛛中间件123SPIDER_MIDDLEWARES = &#123; 'MySpider.middlewares.MySpiderMiddleware': 543,&#125; 4.相应处理 现在已经知道进程是否正常、爬虫出错在哪处理。那么如何处理呢？ 4.1 继续运行 第一种继续运行的方式，可以使用死循环，也可以使用调度任务。 死循环实现比较简单，在同一个代码中，开启一个进程执行Scrapy爬虫，一个进程实现监控。（不推荐） 12345678910111213#偷懒使用死循环的方式 while True: p = os.popen('tasklist') pid = getPid() # 写个读文件的方法 isAlive = p.read().count(pid) != 0 count = count +1 print( \"%s %s 次是 %s\" %(datetime.datetime.now(),count,isAlive) ) if(isAlive==False): my_pro = Process(target=executeSpider) my_pro.start() with open(\"pid.txt\",\"w\") as f: f.write(my_pro.getpid()) time.sleep(60) 第二种利用中间件返回Request让爬虫继续执行：12345def process_exception(self, request, exception, spider): with open(\"exceptionLog.txt\", \"a\") as f: msg = \"%s : %s\\n\" %(datetime.datetime.now(),exception) f.write(msg) #手动记录日志return request 4.2 通知第一种使用窗口弹出，适合在电脑工作时跑的爬虫，这个窗口提醒会置顶，达到提醒的目的，同时程序也会阻塞，需要确认之后才会继续，当然如果有异常的话，也不需要继续了（不适合打游戏时开需要安装win32库： pip install pywin321win32api.MessageBox(0, \"爬虫进程异常，请查看\", \"提醒\", win32con.MB_SYSTEMMODAL) 第二种使用邮件通知，适合不在电脑目前时跑的爬虫。（这个参考下一篇博文，封装一个发邮件的类，调用一下便ok。 5. 总结使用一个工具需要慢慢的熟悉，第一个监控进程的方法是在没有弄清有两个中间件导致一直没找到解决方法所想的（囫囵吞枣学了一下Scapy。使用弹窗提醒还可以，同时也可以使用在其他可以在命令行所运行的程序上，见参考博客 借鉴博客如下https://www.jb51.net/article/163273.htmhttps://blog.csdn.net/weixin_41990342/article/details/81907263","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Ubuntu系统安装和设置（资源整合）","slug":"install-ubuntu","date":"2019-12-29T13:54:01.000Z","updated":"2019-12-29T14:03:13.434Z","comments":true,"path":"2019/12/29/install-ubuntu/","link":"","permalink":"http://yoursite.com/2019/12/29/install-ubuntu/","excerpt":"","text":"Ubuntu系统安装和设置（资源整合） 出于需要，安装一个Ubuntu的虚拟机，期间也是各种问题和麻烦（基本上是后续弄自己的东西的问题。前期安装大概用到了一下的帖子，我只是资源的搬运工。（侵删 下载 推荐国内镜像（阿里）http://mirrors.aliyun.com/ubuntu-releases/14.04/http://mirrors.aliyun.com/ubuntu-releases/16.04/http://mirrors.aliyun.com/ubuntu-releases/18.04/ 这里有一个桌面版和服务器版。区别在于： 桌面版： 有界面，内置功能少，需要自己安装 服务器版： 无界面，集成服务器所需大部门功能 安装 https://blog.csdn.net/qq1326702940/article/details/82322079 基础设置安装vmtool https://jingyan.baidu.com/article/6fb756ec4079cf241858fba9.html 在VMware上点了按照VMtools之后不用管，之后会自动弹出来 运行是 sudo ./vmware-install.pl 直接点没用 配置网络 https://blog.csdn.net/qi_yue_yu/article/details/52694252 设置apt-get源默认使用国外的源，速度会慢到令人发指。 https://blog.csdn.net/zgljl2012/article/details/790651741.在输入镜像地址那里，可以用到VMtools 的复制粘贴功能2.我的没有gedit命令，就使用了vi，但是退格键有时候会失灵。 https://blog.csdn.net/kang123488/article/details/79512721（第一个方法） 安装SSH并用Xshell等工具连接使用CentOS的习惯，还可以通过这个传文件 https://jingyan.baidu.com/article/54b6b9c08ff5c42d583b473c.html 其他问题过程可以会遇到其他问题，一般用错误提示的组后那一段字去百度，都有相应的解决方法","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]},{"title":"在线投票系统（基地项目1）","slug":"voteOnlineSystem","date":"2019-07-13T07:29:14.000Z","updated":"2019-07-13T07:33:31.400Z","comments":true,"path":"2019/07/13/voteOnlineSystem/","link":"","permalink":"http://yoursite.com/2019/07/13/voteOnlineSystem/","excerpt":"","text":"在线投票在线投票系统，用户注册成为网站会员之后在系统中发起投票和进行投票，其次可以根据用户自己输入的信息分析用户行为和占比。主要用于人物评选，市场用户喜好分析。 项目功能概述投票包含投票标题，类型（单选或多选），开始时间和结束时间，已经投票选项。普通用户可以在系统查看别人发起的投票进行投票，也可以维护自己发起投票，比如修改和删除，完成投票或者投票结束之后就可以查看投票结果。管理员可以管理所有用户，升级权限或者禁用账号，对所有投票进行查看和删除。 技术选型基于JavaWeb,采用Mysql存储数据，使用nginx作为图片服务器进行图片代理。html/js/css/jquery，bootstrap 等前端技术。 前后端接口交互设计混用jquery 和 jstl/el表达式进行页面渲染，因此在servlet里面有两种返回方式，一种是页面跳转，一种是内容输出。内容输出对应的ajax请求，请求转发采用jstl与el表达式渲染。前期确定好交互的接口，和servlet是有必要的，可以有效进行拦截权限控制。 数据库方面优化到第三范式，单表信息存储对象内容，也就是将java的面向对象转成关系型表示。采用主外键连接彼此的依赖关系。 项目展示 更多也面就不截图了。 心得总结通过这次实训，又积累了一个项目经验，了解了一个业务的流程。这次项目还是不够完善，存在架构和耦合方面的问题，感觉代码并不易于理解，发现自己的缺点也是自己以后前进的方向。这次项目的遗憾有以下几点。首先前期需求不够完善，仅仅是局部的内容。因此设计上受到了局限性，给后期业务带来些许麻烦。其次主要的弱点和不足均表现在前端，前后端交互原本是数据的交换，后端提供一个数据接口，将前端提供的数据加工之后再返回的过程。数据的交互不要求页面，也不顾及用户体验。但是前端是用户和系统的桥梁，如果这座桥梁不够美观和牢固，自然也没有用户会使用这个系统。虽然主要是走后端，但是对前端知识的匮乏也可能会成为后期发展的桎梏。","categories":[{"name":"code","slug":"code","permalink":"http://yoursite.com/categories/code/"}],"tags":[{"name":"project","slug":"project","permalink":"http://yoursite.com/tags/project/"}]},{"title":"深度剖析Spring（一） 体系结构","slug":"Spring1IOC","date":"2019-04-22T12:30:25.000Z","updated":"2019-04-22T15:21:27.271Z","comments":true,"path":"2019/04/22/Spring1IOC/","link":"","permalink":"http://yoursite.com/2019/04/22/Spring1IOC/","excerpt":"深度剖析Spring（一） 体系结构前言Spring作为一个轻量级的Java开发框架，简化了Java应用开发的复杂性，减少了代码的耦合度。不过在初次接触Spring的时候，对于各种配置文件，还是有点头疼，甚至觉得复杂化了开发过程。不过在学到后面的时候，发现Spring还是挺好用的。Spring同时也是一个工具，一个大部分开发者都喜欢的工具。所以在掌握其使用方法的同时，了解其设计理念，其源码实现，对于开发也是有好处的。","text":"深度剖析Spring（一） 体系结构前言Spring作为一个轻量级的Java开发框架，简化了Java应用开发的复杂性，减少了代码的耦合度。不过在初次接触Spring的时候，对于各种配置文件，还是有点头疼，甚至觉得复杂化了开发过程。不过在学到后面的时候，发现Spring还是挺好用的。Spring同时也是一个工具，一个大部分开发者都喜欢的工具。所以在掌握其使用方法的同时，了解其设计理念，其源码实现，对于开发也是有好处的。 参考文章: https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/http://cmsblogs.com/?p=2652 设计理念Spring的设计类似于Java面向对象理念，管理的对象就是我们所定义的bean。所以Bean在Spring中起到很大的作用，我们所定义的对象，由Spring包装成自己的Bean对象进行管理。同时为我们提供了一个存放对象的容器，这个容器便是管理Bean对象的，需要对象时我们可以在容器中取。同时在该容器中，Spring会建立其之间的依赖关系，也就是所谓的依赖注入。 引用一段参考文章中的原文，大致讲了Bean的重要性和spring理念。 Bean 在 Spring 中作用就像 Object 对 OOP 的意义一样，没有对象的概念就像没有面向对象编程，Spring 中没有 Bean 也就没有 Spring 存在的意义。就像一次演出舞台都准备好了但是却没有演员一样。为什么要 Bean 这种角色 Bean 或者为何在 Spring 如此重要，这由 Spring 框架的设计目标决定，Spring 为何如此流行，我们用 Spring 的原因是什么，想想你会发现原来 Spring 解决了一个非常关键的问题他可以让你把对象之间的依赖关系转而用配置文件来管理，也就是他的依赖注入机制。而这个注入关系在一个叫 Ioc 容器中管理，那 Ioc 容器就是被 Bean 包裹的对象。Spring 正是通过把对象包装在 Bean 中而达到对这些对象的管理以及一些列额外操作的目的。 控制反转（IOC）现在我们知道在Spring中最重要的是Bean，那么谁负责管理这些Bean，以及如何管理这些Bean呢？这就不得不提到IOC了，IOC全称 Inversion of Control ，译为“ 控制反转 ”，关于IOC的详解 。面向对象开发应用，一般是几个类进行合作，从而完成工作(如在Service类中需要一个Dao类来进行数据存取)，这样这几个类就形成了依赖关系。如果合作的类过多，其代码中自然会有许多显式的构造对象代码，也就产生了大量耦合。因此采用第三方来进行对象依赖管理进行解耦，那这个第三方也就是IOC。所谓反转也是因为有了IOC，曾经需要显式new的对象，现在只需要被动接受就可以了，因此意为：控制反转。 核心组件弄清除何为控制反转之后，我们再来了解下一个问题:Spring是通过什么来完成控制反转的？Spring提供了若干组件来支持用户开发工作，其中最为核心的是：Core,Context,Beans。由他们组成核心骨骼，其余的特性功能如AOP，Web都在其核心之上。这里的组件也就是Spring提供的相关Jar包，来完成所需工作。 Beans组件Beans组件主要负责Bean的定义、创建、解析。对于使用者而言只需要关注Bean如何定义，而创建和解析由Spring来完成。 Bean定义，BeanDefinition体系，描述Spring中的Bean对象，是Spring中基本的数据结构，封装了用户定义的object和别名等信息，后续的创建和解析都和Bean定义息息相关。 AttributeAccessor 定义用于附加和访问元数据的通用的接口BeanMetadataElement 提供了一个getResource()方法,用来传输一个可配置的源对象AbstractBeanDefinition 保存bean的相关设置属性RootBeanDefinition 表明它是一个可合并的bean definition：即在spring beanFactory运行期间，可以返回一个特定的bean Bean解析，BeanDefinitionReader体系，解析Spring配置文件，将其转换为Spring的内部数据结构BeanDefinition。 BeanDefinitionReader 指定了加载方法EnvironmentCapable 通过getEnvironment方法取得与此组件相关联的环境，用于类型检测AbstractDefinitionReader 提供常用属性，例如要处理的bean工厂和用于加载bean类的类加载器XmlBeanDefinitionReader 加载xml中的bean定义PropertiesBeanDefinitionReader 加载属性文件bean定义GroovyBeanDefinitionReader 支持Groovy 定义文件（Groovy是基于JVM的开发语言） bean创建，BeanFactory体系，纯粹的Bean容器，维护着一个DefinitionMap对象，根据Definition的描述进行Bean的管理和创建 BeanFactory 用于访问Spring bean容器的顶级接口，基础容器ListableBeanFactory 表示bean是可列表的HierarchicalBeanFactory 表示bean之间存在继承分层关系AutowireCapableBeanFactory 定义Bean的自动装配规则 SingletonBEanRegistry 定义单例类注册的方法ConfigurableBeanFactory 继承了分层和单例类注册的功能ConfigurableListableBeanFactory 分层列表可自动装配DefaultListableBeanFactory 最终默认实现类 在这个体系里面,每个高层接口的功能都比较单一化的,在逐步的继承中,通过合并多个接口再组合成复杂功能的接口。之所以定义这么多接口,是为了区分在Spring内部对象的传递和转化中,对对象的数据访问做限制,使得每个接口有特定的使用场合 大致关系为：使用者编写Spring配置文件（定义Bean和其依赖关系），由BeanDefinitionReader解析配置文件，将其中的Bean定义（&lt;bean&gt;）转换为BeanDefinition类，然后交由BeanFactory来管理。 Core组件发现、建立、维护每个Bean之间的关系所需的一系列工具。其中包含了很多关键类，有一个重要的组成部分便是资源的获取方式。 资源Resource体系，它的每一个类都代表了对一种资源的封装，对使用者而言，消除了不同资源类型的差异。对资源提供者而言,InputStreamSource接口中有一个getInputStream ,返回该资源的InputStream便可. InputStreamSource 定义getInputStream()方法获取资源的inputStreamResource 资源描述接口AbstractResource 实现部分预处理方法,如: 判断资源是否存在contextResource 从应用上下文容器获取资源的接口其余各种具体资源 资源加载ResourceLoader，对之前的封装的资源提供加载机制。 ResourceLoader 资源获取接口,获取类类加载器或资源(Resource)DefaultResourceLoader 默认实现ResourcePatternResolver 路径匹配解析具体实现类 在这里我们可以了解到,Spring对资源文件的管理,类似于一种外观模式,提供了一个资源接口,具体如何获得资源,由子类实现. context组件这个就是我们使用Spring时定义的ApplicationContext，其提供一个运行时环境，记录各个对象的运行状态。同时也继承了Bean组件和core组件部分功能，三个组件一起构成Spring核心。 从上图可以看出，Context 是把资源的加载、解析和描述工作委托给了 ResourcePatternResolver 类来完成，他相当于一个接头人，他把资源的加载、解析和资源的定义整合在一起便于其他组件使用。同时继承了 BeanFactory, 也说明Spring 容器中运行的主体对象是 Bean. pplicationContext 的子类主要包含两个方面： ConfigurableApplicationContext 表示该 Context 是可修改的，也就是在构建 Context 中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最经常使用的是可更新的 Context，即 AbstractRefreshableApplicationContext 类。 WebApplicationContext 顾名思义，就是为 web 准备的 Context 他可以直接访问到 ServletContext，通常情况下，这个接口使用的少。再往下分就是按照构建 Context 的文件类型，接着就是访问 Context 的方式。这样一级一级构成了完整的 Context 等级层次。 总结通过了解Spring的设计理念与三个核心组件,需要明白以下几个问题:1.Spring的设计理念 面向对象,简化开发复杂性,减少代码耦合度. 2.Spring基础功能IOC是什么 控制反转,利用第三方(IOC)管理多个类的依赖关系.由主动获取变成被动接受 3.三大核心组件是什么 Beans: bean的定义(数据结构Definition) , 创建(BeanFactory), 解析(BeanDefinitionReader). 用户定义bean配置文件, 由Spring解析成bean的数据结构,由BeanFactory进行管理. Core: 提供很多工具类,重要的有资源封装(Resource)和资源获取(ResourceLoader). Context: 应用上下文,运行时环境,整合三大核心组件为用户提供服务. 这里只是了解部分简单的Spring核心功能,从简单了来说,就是读取配置文件到Map里面,然后我们去Map取. 往复杂了说,需要考虑各种扩展灵活性,因此还需要对spring进一步了解.","categories":[{"name":"learning","slug":"learning","permalink":"http://yoursite.com/categories/learning/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"动态规划分析步骤与代码（背包、最大公共子串）","slug":"DynamicProgramming","date":"2019-04-14T13:26:24.000Z","updated":"2019-04-14T11:36:39.799Z","comments":true,"path":"2019/04/14/DynamicProgramming/","link":"","permalink":"http://yoursite.com/2019/04/14/DynamicProgramming/","excerpt":"前言动态规划在《数据结构与算法》中接触过，随后在《软件设计师教程》中也学习过，每次学完没有做记录，感觉会了，但实际上还是有些不理解的。这次在《图解算法》中重新接触到动态规划，讲得挺透彻的，应该要好好记录下来。无论动态规划的问题有多么形式多样，只要了解了解题思路和原理。再多加练习，肯定能掌握的。 基本思想 其基本思想是将待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 这是《软件设计师教程》中对动态规划思想的描述。看起来很简单，就把大问题划成小问题。恰恰难的也就是如何将大问题化解成小问题。通过这篇文章，来慢慢体会这个划分的过程。","text":"前言动态规划在《数据结构与算法》中接触过，随后在《软件设计师教程》中也学习过，每次学完没有做记录，感觉会了，但实际上还是有些不理解的。这次在《图解算法》中重新接触到动态规划，讲得挺透彻的，应该要好好记录下来。无论动态规划的问题有多么形式多样，只要了解了解题思路和原理。再多加练习，肯定能掌握的。 基本思想 其基本思想是将待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 这是《软件设计师教程》中对动态规划思想的描述。看起来很简单，就把大问题划成小问题。恰恰难的也就是如何将大问题化解成小问题。通过这篇文章，来慢慢体会这个划分的过程。 经典背包问题背包可以装 4 磅；音响 3000元，4磅；笔记本电脑，2000元，3磅；吉他，1500元，1磅。书中是直接提供的自底向上解题的过程。在这里我们先从上至下分析一下问题： 拿还是不拿？对于每一个物品，我们都有两个选择，拿或者不拿。我们需要解决的是：拿哪些能达到最高价值？ 现在我们什么都没拿，0价值，4磅空间。我们先考虑吉他： 拿吉他：现在背包价值1500，剩余空间3磅。不拿吉他：背包价值0，剩余空间4磅。 然后在拿或不拿的基础上考虑音响，拿了吉他，价值1500元，剩余3磅空间： 拿音响：音响占用空间4磅 &gt; 剩余空间3磅，所以拿不下。现在背包价值1500，剩余3磅空间。不拿音响：和原来一样，背包价值1500，剩余空间3磅。 不拿吉他，价值0元，剩余4磅空间： 拿音响：背包价值3000，剩余0空间。不拿音响：背包价值0，剩余4空间。 然后在前两者组合的基础上再考虑笔记本电脑，其中组合为： 1.拿了吉他，拿不下音响：剩余3空间2.拿了吉他，不拿音响：剩余3空间3.没拿吉他，拿音响：剩余0空间4.没拿吉他，也没拿音响：剩余4空间 我们发现，1和2剩余的3磅空间刚好再拿个笔记本电脑，且1组合价值最高，而4组合仅拿了电脑，价值为2000，不如1组合。似乎到这里我们仍然得不到什么结论，以上的方法，类似一个排列组合，查看所有的组合方式中的最高价值。但是我们却已经完成了 背包问题的第一步：刻画最优子结构 拿了某物品，和剩下空间的最优解不拿某物品，和剩下空间的最优解 一点一点挤我们完成了从上到下的分析，子问题是在剩下的空间里选择最值钱的物品。然后考虑第二步：合并子问题，也就是自下而上合并。 假如剩下1空间，我们拿什么最划算？假如剩下2空间，我们拿什么最划算？…… 因此我们需要画一个表格用来记录子问题的最优解： 行：当前行和之前行表示可以选择的物品列：表示背包的剩余空间 因为我们考虑的是剩余空间，因此填充列：剩余空间1：很明显，剩余空间1时，我们只能拿吉他，因此在第一列，我们填入吉他与价格： 1 2 3 4 吉他（G） 1500 （G） 音响（S） 1500 （G） 笔记本 (C) 1500 （G） 剩余空间2：我们仍然不能拿其他的物品，因此在第二列，我们填入吉他与价格： 1 2 3 4 吉他（G） 1500 （G） 1500 （G） 音响（S） 1500 （G） 1500 （G） 笔记本 (C) 1500 （G） 1500 （G） 剩余空间3：在这里，我们发现，当遇到笔记本电脑时，可以装下而且比吉他价格高，因此我们在笔记本行填入笔记本： 1 2 3 4 吉他（G） 1500 （G） 1500 （G） 1500 （G） 音响（S） 1500 （G） 1500 （G） 1500 （G） 笔记本 (C) 1500 （G） 1500 （G） 2000 （C） 剩余空间4：在这里我们又发现，遇到音响时，可以装下，且价格为3000： 1 2 3 4 吉他（G） 1500 （G） 1500 （G） 1500 （G） 1500 （G） 音响（S） 1500 （G） 1500 （G） 1500 （G） 3000 （S） 笔记本 (C) 1500 （G） 1500 （G） 2000 （C） 最后一格怎么办呢，现在最大价格是3000，如果拿电脑，就装不下音响，价值只有2000，价值没有之前高。但 如果拿电脑，背包则还可以装1空间的物品。因此我们看看空间剩1时，可以装的最高价格是什么东西。我们之前表中已经填过，是吉他。且笔记本+吉他的价格为3500，超过了音响的价格。所以我们在最后一格中填入 1 2 3 4 吉他（G） 1500 （G） 1500 （G） 1500 （G） 1500 （G） 音响（S） 1500 （G） 1500 （G） 1500 （G） 3000 （S） 笔记本 (C) 1500 （G） 1500 （G） 2000 （C） 3500（C/G） 在这里我们发现，如果可选择的物品重量大于剩余空间时，是不能放入背包的。而当前可选物品可以放进去时，就需要进行比较。那么，是比较什么呢？至此，我们可以得到计算剩余空间最大价值的公式 ： 因为当前行是需要选择是否拿的物品，所以使用上一行的值作为参照。 比如第三行3列：笔记本，剩余空间3时，就要选择比较： 拿：放下吉他，价值2000，剩余空间0不拿：价值1500，剩余空间3 显而易见，拿比不拿价格高。 音响同理； 在比如第三行3列：笔记本，剩余空间4时，选择比较如下： 拿：放下音响，价值2000，剩余空间1。还可以拿吉他，一共价值3500不拿：价值3000，剩余空间0 显而易见，拿比不拿价格高。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//填表计算 最优解int** KnapsackDP(int n,int W,int* weights,int* values)&#123; int i,w; //因为数组下标是从0开始且需要用上一行做基础，所以 n+1 ， w + 1 int **c = (int **)malloc(sizeof(int *) * (n+1)); for(i=0; i&lt;=n; i++) &#123; c[i]=(int *)malloc(sizeof(int)*(W+1)); //初始化所有格子为0 for(w = 0 ; w&lt;=W ; w++) c[i][w] = 0; &#125; //从最小空间开始 for(w= 1 ; w &lt;= W ; w++) &#123; //所有物品 for(i = 1 ; i&lt;=n ; i++) //判断当前物品是否放得下 if(weights[i-1] &lt;= w) &#123; //比较放和不放的价值 if(values[i-1] + c[i-1][w - weights[i-1]] &gt; c[i-1][w]) //放，价值为当前物品的价值加上剩余空间的最大价值 c[i][w] = values[i-1] + c[i-1][w-weights[i-1]]; else c[i][w] = c[i-1][w]; &#125; else &#123; //放不下，直接沿用之前的 c[i][w] = c[i-1][w]; &#125; &#125; return c;&#125;//根据最优解值找最优解序列void OutputKnapsackDP(int n,int W , int* Weights,int *Values, int **c)&#123; int x[n]; int i; for(i = n ; i &gt; 1 ; i--)&#123; if(c[i][W] == c[i-1][W]) //判断是否包含该物品 x[i-1] =0; else &#123; x[i-1] = 1; W = W- Weights[i-1]; //包含，修改背包容量 &#125; &#125; if(c[1][W] == 0) //判断第一个物品是否放入 x[0] = 0; else x[0] = 1; for(i = 0 ; i&lt; n ; i ++)&#123; if(x[i]) printf(&quot;Weight:%d , Value %d\\n&quot;,Weights[i],Values[i]); &#125;&#125;int main()&#123; int n = 3,w = 4; int weights[4] = &#123;1,4,3&#125;; int values[4]= &#123;1500,3000,2000&#125;; int** c; int i,j; c = KnapsackDP(n,w,weights,values); for(i = 0 ; i &lt;= n ; i ++) &#123; for(j = 0 ; j &lt;= w ; j++) &#123; printf(&quot;%d &quot;, c[i][j]); &#125; printf(&quot;\\n&quot;); &#125; printf(&quot;打印最优结构\\n&quot;); OutputKnapsackDP(n,w,weights,values,c); return 0;&#125; 运行结果如下： 最长公共子序列《软件设计师教程》中的描述： 子序列是指从给定序列中随意地(不一定是连续的)去掉若干元素后所形成的序列。如X = ABCBDAB , Y = BCDB，则Y是X的一个子序列。若给定两个X和Y，如果Z同时是X和Y的子序列，那称Z是X和Y的公共子序列。最长公共子序列问题定义为：给定序列X和Y，求这两个序列的最长公共子序列。 有点抽象化，所以看起来很费劲，那看一下《图解算法》的例子:那我们怎么猜用户应该输入的是什么呢？是fish？还是vista？ 当然是看和哪个单词重合度更高一点，因此我们便采用最长公共序列算法。 谁和谁一样使用fish和hish不太能体现最长序列的分析，我们采用软考教程的例子： X = ABCBDABY = BDCABA 人工判断的话，自然是先在两个序列中找到第一个相等的，记下来 AB &amp; B -&gt; B 然后再往后找第二个一样的 C &amp; DC -&gt; C也就是 ABC &amp; BDC - &gt; BC 继续 B &amp; AB -&gt; B也就是 ABCB &amp; BDCAB -&gt; BCB 然后 DA &amp; A -&gt; A也就是 ABCBDA &amp; BDCABA -&gt; BCBA Y序列已经没有字符了，所以我们也就找完了。可以发现，后面被寻找的内容都是在前面找到的相等的字母后面，也就是说CBDA &amp; DCABA - &gt; CBA 。都去除一个相同的字母结尾的序列，剩下的公共子串也是其剩余序列的最长公共子串。 一个一个比那计算机应该怎么进行比较呢，它不能像人一样一次比较多个字母，也不知道何时两个字母会相等。所以就要一个一个字母进行比较，同时记录比较情况。 X = FISHY = HISH F I S H H I S H 这个表记录的就是子字符串的公共子串字母个数。按行进行分析第一行，H 分别与 F 、 FI 、 FIS 、 FISH 的最大子串第二行，HI 分别与 F 、 FI 、 FIS 、 FISH 的最大子串第三行，HIS 分别与 F 、 FI 、 FIS 、 FISH 的最大子串第四行，HISH 分别与 F 、 FI 、 FIS 、 FISH 的最大子串 按照之前分析的，如果字母相等的话，就去掉相同字母的最长公共子串 + 1 。在不相等的情况下，则需要判断去掉比较双方的其中一个之后哪一个的 值比较大，以记录最长的公共子串。 如 HI &amp; FI : I 相等，那就 H &amp; F（去掉比较字符I ）的最长公共子串值 0 + 1 。HI &amp; FIS : I 不等于 S , 选择 HI &amp; FI （去掉 S） 的值 1 与 H &amp; FIS （去掉 I）的值 0 中较大的一个。 依次类推得到下表： F I S H H 0 0 0 1 I 0 1 1 1 S 0 1 2 2 H 0 1 2 3 这里我们知道了最终结果的值是3，但是好像看不出来公共子串的序列是什么。所以我们需要记录序列路径。 上表示 去掉比较的行字符 比 去掉比较的列字符 更大 左表示 去掉比较的列字符 比 去掉比较的行字符 更大 左上表示 比较字符相等，去掉比较字符之后 + 1 x F I S H y 0 0 0 0 0 H 0 0 ↑ 0 ↑ 0 ↑ 1 ↖ I 0 0 ↑ 1 ↖ 1 ← 1 ↑ S 0 0 ↑ 1 ↑ 2 ↖ 2 ← H 0 0 ↑ 1 ↑ 2 ↑ 3 ↖ 这时我们便可以看到，从 H -&gt; S -&gt; I 逆序过来就是最长公共子序列的字母了。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/*** 求出最长序列*/int** Lcs_Lenth(const char * str1, const char * str2, int str1_length, int str2_length)&#123; int i,j; //记录最长序列 int **l= (int **)malloc(sizeof(int *) * (str1_length + 1)); //记录序列导向 int **b= (int **)malloc(sizeof(int *) * (str1_length + 1)); //分配空间 for(i = 0 ; i &lt;= str1_length ; i ++) &#123; l[i] = (int *) malloc( sizeof(int *) * str2_length + 1) ; b[i] = (int *) malloc( sizeof(int *) * str2_length + 1) ; for(j = 0 ; j &lt;= str2_length ; j ++) &#123; l[i][j] = 0 ; b[i][j] = -1; &#125; &#125; //依次比较 for(i = 1 ; i &lt;= str1_length ; i++) for( j = 1 ; j&lt;=str2_length ; j++) &#123; //相等 if(str1[i-1] == str2[j-1]) &#123; l[i][j] = l[i-1][j-1] + 1; //去掉相同字母，i-1，j-1; b[i][j] = 0 ; //代表左上 &#125; else if(l[i-1][j] &gt;= l[i][j-1]) //去掉行比较字母比较大 &#123; l[i][j] = l[i-1][j]; //行级 i - 1 b[i][j] = 1; //代表上方 &#125; else &#123; l[i][j] = l[i][j-1]; //列级 j - 1 b[i][j] = 2; //代表 右方 &#125; &#125; printf(&quot;输出长度\\n&quot;); for(i = 0 ; i &lt;= str1_length ; i++) &#123; for( j = 0 ; j&lt;=str2_length ; j++) &#123; printf(&quot;%d &quot;, l[i][j]); &#125; printf(&quot;\\n&quot;); &#125; printf(&quot;输出导向\\n&quot;); for(i = 0 ; i &lt;= str1_length ; i++) &#123; for( j = 0 ; j&lt;=str2_length ; j++) &#123; switch(b[i][j])&#123; case 0: printf(&quot;↖&quot;); break; case 1: printf(&quot;↑&quot;); break; case 2: printf(&quot;←&quot;); break; default : printf(&quot;0 &quot;); &#125; &#125; printf(&quot;\\n&quot;); &#125; return b;&#125;//递归输出公共子序列序列void OutputLcs(const char *str1, const int **b, int str1_length, int str2_length )&#123; //直到一个字符串比较完毕 if(str1_length ==0 || str2_length ==0) return ; //表示两个字符相等 if(b[str1_length][str2_length] == 0) &#123; //去掉该字符 OutputLcs(str1,b,str1_length-1, str2_length - 1 ); printf(&quot;%c&quot;,str1[str1_length - 1]); &#125; //表示去掉行级比较大 else if(b[str1_length][str2_length] == 1) &#123; //去掉其中一个比较字符 OutputLcs(str1,b,str1_length - 1,str2_length); &#125; else &#123; //去掉另外一个 OutputLcs(str1,b,str1_length,str2_length - 1); &#125;&#125;int main()&#123; char* str1 = &quot;ABCBDAB&quot;; char* str2 = &quot;BDCABA&quot;; int** b =Lcs_Lenth(str1,str2,strlen(str1),strlen(str2)); printf(&quot;输出序列\\n&quot;); OutputLcs(str1,b,strlen(str1),strlen(str2)); return 0;&#125; 结果如下 总结 动态规划解决的是问题具有最优子结构，总问题的解可以由子问题的解合并得来 子问题具有重叠性，有许多的子问题是重复的 采用填表法，即记录子问题的解不再重复结算","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"SpringMVC 拦截器浅析与实例","slug":"interceptor","date":"2019-04-12T07:27:18.000Z","updated":"2019-04-18T06:49:52.200Z","comments":true,"path":"2019/04/12/interceptor/","link":"","permalink":"http://yoursite.com/2019/04/12/interceptor/","excerpt":"SpringMVC 拦截器浅析与实例拦截器的作用，类似于传统servlet的过滤器Filter，在执行请求时，做出预处理，与后处理。不过拦截器中，还有一个中处理（暂且这么称呼）。过滤器我们通常用来执行权限验证，统计访问，计算处理时间等等。拦截器也一样，下面先看看DispatchServlet中拦截器的参与过程。","text":"SpringMVC 拦截器浅析与实例拦截器的作用，类似于传统servlet的过滤器Filter，在执行请求时，做出预处理，与后处理。不过拦截器中，还有一个中处理（暂且这么称呼）。过滤器我们通常用来执行权限验证，统计访问，计算处理时间等等。拦截器也一样，下面先看看DispatchServlet中拦截器的参与过程。 源码预览doDispatch这个方法是SpringMVC前端总控制器处理请求的方法，其中，有关拦截器的代码如下：其中的mappedHandler是一个局部HandlerExecutionChain属性，保存了真正的自定义处理器与拦截器链。 HandlerExecutionChain可以看到，其中有一个用来存储自定义的控制器的object，有一个存储拦截器的数组和列表。列表方便添加管理拦截器，数组能够快速通过下标进行访问。然后就有一个整型的下标，这个是用来存储预处理时，处理到了哪一个拦截器的下标。具体使用方法如下。这几个就是DispatchServlet中调用的方法。通过预处理和后处理的源码，不难看出下标的用途:顺序执行预处理，逆序执行后处理。同理，业是逆序执行中处理。同时，当发生异常时，保证了拦截器能从正确的下标执行后处理。 HandlerInterceptor拦截器的接口，自定义的拦截器需要实现该接口，同时覆写三个方法。HandlerExecutionChain中的预处理便是调用了每一个拦截器的实现方法。需要注意的是：预处理中返回的是布尔值，如果返回false，便会使整个doDispatch()方法返回，因此，该处理也就被忽视了。所以在需要返回false值之前，指定重定向的页面。不然就会显示一片空白。 使用示例登陆控制器1234567891011121314151617181920212223242526272829/** * @author !N * 2019年4月11日 */@Controllerpublic class LoginController &#123; @RequestMapping(&quot;/login&quot;) public String login(User user,HttpSession session,HttpServletRequest request,HttpServletResponse res)&#123; System.out.println(&quot;请求登陆&quot;); if(user.getName().equals(&quot;user&quot;) &amp;&amp; user.getPwd().equals(&quot;123&quot;))&#123; session.setAttribute(&quot;user&quot;, user); return &quot;redirect:/toindex&quot;; &#125; return &quot;redirect:/toindex&quot;; &#125; @RequestMapping(&quot;/gotomanage&quot;) public String managerPage()&#123; System.out.println(&quot;自定义处理器&quot;); return &quot;manage&quot;; &#125; @RequestMapping(&quot;/toindex&quot;) public String toIndex()&#123; return &quot;redirect:/index.jsp&quot;; &#125;&#125; 假定测试用户名和密码。利用session记录用户登陆状态。使用重定向返回首页（正常登陆成功之后跳转到其他页面，直接返回就好了）。 自定义拦截器1234567891011121314151617181920212223242526272829303132333435/** * @author !N * 2019年4月11日 * 权限拦截器 */public class PermissionInterceptor implements HandlerInterceptor&#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;Permision： 预处理，请求路径：&quot; + request.getRequestURI()); if(request.getSession().getAttribute(&quot;user&quot;)!=null)&#123; System.out.println(&quot;已经登陆&quot;); return true; &#125; System.out.println(&quot;未登陆，跳转到首页&quot;); response.sendRedirect(request.getContextPath() +&quot;/index.jsp&quot;); return false; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;=== 中处理 Post===&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;=== 后处理 After===&quot;); &#125; &#125; 利用session中的参数判断是否登陆。 jsp页面1234567&lt;a href=&quot;gotomanage&quot;&gt;进入后台&lt;/a&gt;&lt;br/&gt;&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;pwd&quot; &gt; &lt;input type = &quot;submit&quot; value=&quot;login&quot;&gt;&lt;/form&gt; 配置文件在配置servlet-web的文件中添加如下配置。1234567891011&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 配置拦截器需要拦截的路径 --&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt; &lt;!-- 配置不需要拦截作用的路径 --&gt; &lt;mvc:exclude-mapping path=&quot;/login&quot; /&gt; &lt;mvc:exclude-mapping path=&quot;/toindex&quot; /&gt; &lt;!-- 使用哪个拦截器 --&gt; &lt;bean class=&quot;com.jsu.handlernterceptor.PermissionInterceptor&quot; /&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 如果有异常可以更换如下xml文档头12345678910&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; 运行结果未登陆点击首页的进入后台登陆后点击进入后台（自己新建文件） 总结 拦截器有三个处理过程（前，中，后），分别在处理器之前；处理器后，视图解析前；视图解析后。 被拦截需要设置重定向加载页面。 拦截器只能拦截请求，不能拦截页面","categories":[{"name":"springmvc","slug":"springmvc","permalink":"http://yoursite.com/categories/springmvc/"}],"tags":[{"name":"springmvc","slug":"springmvc","permalink":"http://yoursite.com/tags/springmvc/"}]},{"title":"SpringMVC文件下载的两种方式","slug":"springmvcdownload","date":"2019-04-09T08:55:39.000Z","updated":"2019-04-09T08:58:02.648Z","comments":true,"path":"2019/04/09/springmvcdownload/","link":"","permalink":"http://yoursite.com/2019/04/09/springmvcdownload/","excerpt":"SpringMVC 实现文件下载文件利用程序实现下载需要设置两个报头： 1．Web服务器需要告诉浏览器其所输出内容的类型不是普通文本文件或HTML文件，而是一个要保存到本地的下载文件。设置Content-Type 的值为：application/x-msdownload。 2．Web服务器希望浏览器不直接处理相应的实体内容，而是由用户选择将相应的实体内容保存到一个文件中，这需要设置Content-Disposition报头。该报头指定了接收程序处理数据内容的方式，在HTTP应用中只有attachment是标准方式，attachment表示要求用户干预。在attachment后面还可以指定filename参数，该参数是服务器建议浏览器将实体内容保存到文件中的文件名称。","text":"SpringMVC 实现文件下载文件利用程序实现下载需要设置两个报头： 1．Web服务器需要告诉浏览器其所输出内容的类型不是普通文本文件或HTML文件，而是一个要保存到本地的下载文件。设置Content-Type 的值为：application/x-msdownload。 2．Web服务器希望浏览器不直接处理相应的实体内容，而是由用户选择将相应的实体内容保存到一个文件中，这需要设置Content-Disposition报头。该报头指定了接收程序处理数据内容的方式，在HTTP应用中只有attachment是标准方式，attachment表示要求用户干预。在attachment后面还可以指定filename参数，该参数是服务器建议浏览器将实体内容保存到文件中的文件名称。 浏览文件提供一个页面浏览文件目录，如果不清楚应该在哪存放文件，可以先输出realpath，再进入目录新建文件夹以及存放部分文件。12345678910111213141516@RequestMapping(&quot;file/show&quot;)public String show(HttpServletRequest request, Model model) &#123; System.out.println(&quot;请求文件查看&quot;); String realpath = request.getServletContext().getRealPath(&quot;&quot;) + &quot;fileUpload\\\\temp\\\\&quot;; File dir = new File(realpath); File files[] = dir.listFiles(); // 获取该目录下的所有文件名 ArrayList&lt;String&gt; fileName = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; files.length; i++) &#123; fileName.add(files[i].getName()); &#125; model.addAttribute(&quot;files&quot;, fileName); return &quot;showDownFiles&quot;;&#125; 浏览文件jsp123456789101112131415161718192021222324&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;c:forEach var=&quot;filename&quot; items=&quot;$&#123;files&#125;&quot;&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/file/down2?filename=$&#123;filename&#125;&quot;&gt;$&#123;filename&#125;&lt;/a&gt; &lt;br /&gt; &lt;/c:forEach&gt; &lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 结果如下： 使用ResponseEntityResponseEntity是一个响应实体，其中包含了返回的头部信息，状态信息以及内容。如下：因此可以将文件解析成二进制流存储进ResponseEntity的body中，同时设置其响应头与状态便可以进行下载。12345678910111213@RequestMapping(&quot;/file/down2&quot;) public ResponseEntity&lt;byte[]&gt; download(@RequestParam String filename, HttpServletRequest request) throws IOException &#123; //通过存放文件目录和文件名获取文件全路径 String filePath = request.getServletContext().getRealPath(&quot;&quot;) + &quot;fileUpload\\\\temp\\\\&quot; + filename; File file = new File(filePath); //定义响应头并设置下载文件报头 HttpHeaders headers = new HttpHeaders(); headers.add(&quot;Content-Type&quot;, &quot;application/x-msdownload&quot;); headers.add(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + URLEncoder.encode(filename, &quot;UTF-8&quot;)); //返回一个响应实体（body，header，status） return new ResponseEntity&lt;byte[]&gt;(FileUtils.readFileToByteArray(file), headers, HttpStatus.OK); &#125; 这里需要注意的是，使用header的setContentType里面，使用的是MediaType类的常量，其中好像并没有找到”application/x-msdownload”类型，经过网络查询发现使用的是：MediaType.APPLICATION_OCTET_STREAM，不过我测试的时候并没有效果（后来发现是status的问题，使用HttpStatus.OK就可以了），因此采用了add手动添加。还有一点就是，使用ResponseEntity，需要一次性将读取出来，如果文件过大可以就会发生OOM异常。如果只有小文件的传输，可以使用ResponseEntity；一旦文件过大，建议采用下面的方式。不过ResponseEntity的好处就在于简洁，只需要获取文件，设置头，然后封装到ResponseEntity返回。 使用Java常规方法Java常规方式，有点类似json响应，服务器接收用户下载文件请求时，获取响应的输出流，加载服务器的文件作为输入流，然后一边从本地输入，一边向客户端传输。这种方式就有效的解决了文件过大会产生OOM异常的问题。同时，如果客户端的连接异常关闭则会抛出异常，可以进行有效的进行捕获进行处理。也可以扩展下载量统计，断点下载（RandomAccessFile）等功能。123456789101112131415161718192021222324252627282930313233343536@RequestMapping(&quot;file/down2&quot;) public String down(@RequestParam String filename, HttpServletRequest request, HttpServletResponse response) &#123; System.out.println(&quot;请求文件下载&quot;); FileInputStream in = null; // 输入流 ServletOutputStream out = null; // 输出流 try &#123; // 获得文件路径 String aFilePath = request.getServletContext().getRealPath(&quot;&quot;) + &quot;fileUpload\\\\temp\\\\&quot;; // 设置下载文件使用的报头 response.setHeader(&quot;Content-Type&quot;, &quot;application/x-msdownload&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + URLEncoder.encode(filename, &quot;utf-8&quot;)); // 读入文件 in = new FileInputStream(aFilePath + &quot;\\\\&quot; + filename); // 得到响应对象的输出流，用于向客户端输出二进制数据 out = response.getOutputStream(); out.flush(); int len = 0; byte b[] = new byte[1024]; while ((len = in.read(b)) != -1 &amp; in != null) &#123; out.write(b, 0, len); &#125; out.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; in.close(); &#125; catch (IOException e1) &#123; &#125; try &#123; out.close(); &#125; catch (IOException e1) &#123; &#125; &#125; return null; &#125;","categories":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/categories/spring/"}],"tags":[{"name":"springmvc","slug":"springmvc","permalink":"http://yoursite.com/tags/springmvc/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"SpringMVC文件上传 原理与实例","slug":"SpringMVCFileUpload","date":"2019-04-08T14:52:18.000Z","updated":"2019-04-08T14:56:00.778Z","comments":true,"path":"2019/04/08/SpringMVCFileUpload/","link":"","permalink":"http://yoursite.com/2019/04/08/SpringMVCFileUpload/","excerpt":"SpringMVC 文件上传 原理与实例SpringMVC除了对数据的封装之外，还对文件组件进行了封装。 流程原理和MultipartResolver接口在DispatcherServlet中定义了一个MultipartResolver属性，如果用户配置了该Bean，启动容器的时候，会自动注入参数，如果用户没有配置，则默认为null。当DispaterServlet收到请求时，它的checkMultipart()方法会调用MultipartResolver的isMultipart()方法判断请求中是否包含了文件且multipartResolver属性存在实例。如果满足条件，则调用MultipartResolver的resolveMultipart()方法对请求数据进行解析，然后将文件数据解析成MultipartFile并封装在MultipartHttpServletRequest对象中返回给DispatcherServlet。","text":"SpringMVC 文件上传 原理与实例SpringMVC除了对数据的封装之外，还对文件组件进行了封装。 流程原理和MultipartResolver接口在DispatcherServlet中定义了一个MultipartResolver属性，如果用户配置了该Bean，启动容器的时候，会自动注入参数，如果用户没有配置，则默认为null。当DispaterServlet收到请求时，它的checkMultipart()方法会调用MultipartResolver的isMultipart()方法判断请求中是否包含了文件且multipartResolver属性存在实例。如果满足条件，则调用MultipartResolver的resolveMultipart()方法对请求数据进行解析，然后将文件数据解析成MultipartFile并封装在MultipartHttpServletRequest对象中返回给DispatcherServlet。 大致流程如下：在MultipartResolver接口中： boolean isMultipart(HttpServletRequest request); // 是否是 multipart MultipartHttpServletRequest resolveMultipart(HttpServletRequest request); // 解析请求 void cleanupMultipart(MultipartHttpServletRequest request); 解析之后的MultipartFile 封装了请求数据中的文件，此时这个文件存储在内存中或临时的磁盘文件中，需要将其转存到一个合适的位置，因为请求结束后临时存储将被清空。 MultipartFile 接口： String getName(); // 获取参数的名称 String getOriginalFilename(); // 获取文件的原名称 String getContentType(); // 文件内容的类型 boolean isEmpty(); // 文件是否为空 long getSize(); // 文件大小 byte[] getBytes(); // 将文件内容以字节数组的形式返回 InputStream getInputStream(); // 将文件内容以输入流的形式返回 void transferTo(File dest); // 将文件内容传输到指定文件中 MultipartResolver 是一个接口，它的实现类如下： CommonsMultipartResolver基于commons-fileupload组件进一步封装，简化了文件上传的代码实现，取消了不同上传组件上的编程差异。因为依赖commons-fileupload组件，所以我们需要导入相关依赖jar包。 实例 导入Maven 依赖 1234567891011&lt;!--文件上传依赖包 --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; 配置文件解析器 123456789101112&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 设定默认编码 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt; &lt;!-- 设定文件上传的最大值为5MB，5*1024*1024 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242880&quot;&gt;&lt;/property&gt; &lt;!-- 设定文件上传时写入内存的最大值，如果小于这个参数不会生成临时文件，默认为10240 --&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;&gt;&lt;/property&gt; &lt;!-- 上传文件的临时路径 --&gt; &lt;property name=&quot;uploadTempDir&quot; value=&quot;fileUpload/temp&quot;&gt;&lt;/property&gt; &lt;!-- 延迟文件解析 --&gt; &lt;property name=&quot;resolveLazily&quot; value=&quot;true&quot;/&gt;&lt;/bean&gt; 编写上传表单 提交方式选择postenctype选择multipart/form-data，表示提交信息中包含文件，使用二进制流提交 1234&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/file/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 控制器处理提交数据12345678910111213141516171819@RequestMapping(&quot;/file/upload&quot;)@Republic String upload(@RequestParam(value = &quot;file&quot;, required = false) MultipartFile file, HttpServletRequest request, HttpSession session) &#123; // 文件不为空 if(!file.isEmpty()) &#123; // 文件存放路径 String path = request.getServletContext().getRealPath(&quot;/&quot;); // 目标文件,使用原文件名 File destFile = new File(path,file.getOriginalFilename()); // 转存文件 try &#123; file.transferTo(destFile); &#125; catch (IllegalStateException | IOException e) &#123; e.printStackTrace(); &#125; &#125; return &quot;success&quot;; //跳转到上传成功页面，新建jsp页面&#125; 源码解析CommonsMultipartResolver 实现了 MultipartResolver 接口，resolveMultipart() 方法如下所示，其中 resolveLazily 是判断是否要延迟解析文件（通过XML可以设置）。当 resolveLazily 为 flase 时，会立即调用 parseRequest() 方法对请求数据进行解析，然后将解析结果封装到 DefaultMultipartHttpServletRequest 中；而当 resolveLazily 为 true 时，会在 DefaultMultipartHttpServletRequest 的 initializeMultipart() 方法调用 parseRequest() 方法对请求数据进行解析，而 initializeMultipart() 方法又是被 getMultipartFiles() 方法调用，即当需要获取文件信息时才会去解析请求数据，这种方式用了懒加载的思想。1234567891011121314151617181920@Overridepublic MultipartHttpServletRequest resolveMultipart(final HttpServletRequest request) throws MultipartException &#123; Assert.notNull(request, &quot;Request must not be null&quot;); if (this.resolveLazily) &#123; //懒加载，当调用DefaultMultipartHttpServletRequest的getMultipartFiles()方法时才解析请求数据 return new DefaultMultipartHttpServletRequest(request) &#123; @Override //当getMultipartFiles()方法被调用时，如果还未解析请求数据，则调用initializeMultipart()方法进行解析 protected void initializeMultipart() &#123; MultipartParsingResult parsingResult = parseRequest(request); setMultipartFiles(parsingResult.getMultipartFiles()); setMultipartParameters(parsingResult.getMultipartParameters()); setMultipartParameterContentTypes(parsingResult.getMultipartParameterContentTypes()); &#125; &#125;; &#125; else &#123; //立即解析请求数据，并将解析结果封装到DefaultMultipartHttpServletRequest对象中 MultipartParsingResult parsingResult = parseRequest(request); return new DefaultMultipartHttpServletRequest(request, parsingResult.getMultipartFiles(), parsingResult.getMultipartParameters(), parsingResult.getMultipartParameterContentTypes()); &#125;&#125; 在上面的代码中可以看到，对请求数据的解析工作是在 parseRequest() 方法中进行的，继续看一下 parseRequest() 方法源码123456789protected MultipartParsingResult parseRequest(HttpServletRequest request) throws MultipartException &#123; // 获取请求的编码类型 String encoding = determineEncoding(request); FileUpload fileUpload = prepareFileUpload(encoding); try &#123; List&lt;FileItem&gt; fileItems = ((ServletFileUpload) fileUpload).parseRequest(request); return parseFileItems(fileItems, encoding); &#125; catch (...) &#123;&#125;&#125; 在 parseRequest() 方法中，首先调用了 prepareFileUpload() 方法来根据编码类型确定一个 FileUpload 实例，然后利用这个 FileUpload 实例解析请求数据后得到文件信息，最后将文件信息解析成 CommonsMultipartFile (实现了 MultipartFile 接口) 并包装在 MultipartParsingResult 对象中。而且从上面解析文件中也可以看到，可以解析出一个List列表，也就是说支持多文件上传，最后附上多文件上传案例。 StandardServletMultipartResolver这个是基于Servlet 3.0来处理 multipart 请求的，但是必须使用支持 Servlet 3.0的容器才可以。 示例 配置文件在spring的配置文件中配置文件解析器用于注入到DispatchServlet12&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot;&gt;&lt;/bean&gt; 因为其是基于servlet所以，其他的参数均在web.xml中配置1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;multipart-config&gt; &lt;!-- 临时文件的目录 --&gt; &lt;location&gt;upload/tem/&lt;/location&gt; &lt;!-- 上传文件最大2M --&gt; &lt;max-file-size&gt;2097152&lt;/max-file-size&gt; &lt;!-- 上传文件整个请求不超过4M --&gt; &lt;max-request-size&gt;4194304&lt;/max-request-size&gt; &lt;/multipart-config&gt;&lt;/servlet&gt; 编写上传表单 1234&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/file/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 控制器处理提交数据 12345678910111213141516171819@RequestMapping(&quot;/file/upload&quot;)public String upload(@RequestParam(value = &quot;file&quot;, required = false) MultipartFile file, HttpServletRequest request, HttpSession session) &#123; // 文件不为空 if(!file.isEmpty()) &#123; // 文件存放路径 String path = request.getServletContext().getRealPath(&quot;/&quot;); // 文件名称 String name = file.getOriginalFilename(); File destFile = new File(path,name); // 转存文件 try &#123; file.transferTo(destFile); &#125; catch (IllegalStateException | IOException e) &#123; e.printStackTrace(); &#125; &#125; return &quot;success&quot;;&#125; 源码分析StandardServletMultipartResolver 实现了 MultipartResolver 接口，resolveMultipart() 方法如下所示，其中 resolveLazily 是判断是否要延迟解析文件（通过XML可以设置）。12345678910public MultipartHttpServletRequest resolveMultipart(HttpServletRequest request) throws MultipartException &#123; return new StandardMultipartHttpServletRequest(request, this.resolveLazily);&#125;public StandardMultipartHttpServletRequest(HttpServletRequest request, boolean lazyParsing) throws MultipartException &#123; super(request); // 判断是否立即解析 if (!lazyParsing) &#123; parseRequest(request); &#125;&#125; 对请求数据的解析工作是在 parseRequest() 方法中进行的，继续看一下 parseRequest() 方法源码1234567891011121314151617181920private void parseRequest(HttpServletRequest request) &#123; try &#123; Collection&lt;Part&gt; parts = request.getParts(); this.multipartParameterNames = new LinkedHashSet&lt;String&gt;(parts.size()); MultiValueMap&lt;String, MultipartFile&gt; files = new LinkedMultiValueMap&lt;String, MultipartFile&gt;(parts.size()); for (Part part : parts) &#123; String disposition = part.getHeader(CONTENT_DISPOSITION); String filename = extractFilename(disposition); if (filename == null) &#123; filename = extractFilenameWithCharset(disposition); &#125; if (filename != null) &#123; files.add(part.getName(), new StandardMultipartFile(part, filename)); &#125; else &#123; this.multipartParameterNames.add(part.getName()); &#125; &#125; setMultipartFiles(files); &#125; catch (Throwable ex) &#123;&#125;&#125; parseRequest() 方法利用了 servlet3.0 的 request.getParts() 方法获取上传文件，并将其封装到 MultipartFile 对象中。 多文件上传续之前CommonsMultipartResolver配置文件 创建多文件页面 123456&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/file/multifile&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 选择文件1:&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br&gt; 选择文件2:&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br&gt; 选择文件3:&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; 控制器处理提交数据 12345678910111213141516171819@RequestMapping(&quot;/file/multifile&quot;) public String multiFileUpload(@ModelAttribute List&lt;MultipartFile&gt; fileList, HttpServletRequest request)&#123; String path = request.getServletContext().getRealPath(&quot;/&quot;); File targetDir = new File(realpath); if(!targetDir.exists())&#123; targetDir.mkdirs(); &#125; for (MultipartFile file: fileList) &#123; File targetFile = new File(realpath,file.getOriginalFilename()); //上传 try &#123; file.transferTo(targetFile); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return &quot;success&quot;; &#125; 其实多文件上次和单文件上传类似，只需把形参列表改成List，在转存的时候，依次遍历就可以了。","categories":[{"name":"learn","slug":"learn","permalink":"http://yoursite.com/categories/learn/"}],"tags":[{"name":"springmvc","slug":"springmvc","permalink":"http://yoursite.com/tags/springmvc/"},{"name":"fileupload","slug":"fileupload","permalink":"http://yoursite.com/tags/fileupload/"}]},{"title":"利用Hexo+Github完成搭建个人博客（2-配置与发布博客）","slug":"create-hexo2","date":"2019-04-06T14:14:14.000Z","updated":"2019-04-06T14:20:59.434Z","comments":true,"path":"2019/04/06/create-hexo2/","link":"","permalink":"http://yoursite.com/2019/04/06/create-hexo2/","excerpt":"寻找模板接上篇，之前已经把博客搭建好了，但是默认的肯定过于单调了些，需要我们进行完善。完善的第一步当然是需要去hexo官方主题找一个中意的模板。里面有很多的主题，点击某个主题之后能进行预览效果。选主题好看是一个方面，另一个是最好有文档教程可以学习配置。不然拿来一个主题，也不能做得酷炫。在预览主题界面一般会有一个GitHub的连接，点击之后会跳转到存放该主题的仓库，里面一般都会有主题的使用教程。我选的是Next主题，Next主题相对来说比较简洁方便，主要是配置教程文档比较详细，在网上也能找到很多相关教程。先来看看GitHub上大佬的示例，然后再确定我们自己的博客应该如何搭配。 Miaia，有Next最近使用教程。uchuhimoAcrisDandy以上几个博客，也说明了Next还提供了不同的布局模板，也就是说，我们选了Next之后，还可以再进行选择。","text":"寻找模板接上篇，之前已经把博客搭建好了，但是默认的肯定过于单调了些，需要我们进行完善。完善的第一步当然是需要去hexo官方主题找一个中意的模板。里面有很多的主题，点击某个主题之后能进行预览效果。选主题好看是一个方面，另一个是最好有文档教程可以学习配置。不然拿来一个主题，也不能做得酷炫。在预览主题界面一般会有一个GitHub的连接，点击之后会跳转到存放该主题的仓库，里面一般都会有主题的使用教程。我选的是Next主题，Next主题相对来说比较简洁方便，主要是配置教程文档比较详细，在网上也能找到很多相关教程。先来看看GitHub上大佬的示例，然后再确定我们自己的博客应该如何搭配。 Miaia，有Next最近使用教程。uchuhimoAcrisDandy以上几个博客，也说明了Next还提供了不同的布局模板，也就是说，我们选了Next之后，还可以再进行选择。 下载主题为了能使用该主题，我们先在存放博客文件的目录下进行Git Bash，将Next下载到本地。 1git clone https://github.com/iissnan/hexo-theme-next themes/next 我们可以看到在themes文件夹下多了一个Next文件夹，这个就是我们下载的主题。下载过来先不急，Hexo和Next为了让用户专注写博客，减小对代码的关注，大多都使用配置进行设置Next主题。所以我们先来了解两个配置文件。 配置站点站点配置文件：位于博客根目录下的 _config.yml，对整个站点的基本内容进行更改。如标题、作者等等。主题配置文件：位于themes\\next下的_config.yml，对当前主题的相关设置。如图标、布局等等。因为它们的文件名是一样的，所以用站点文件和主题文件来区分它们。首先是站点文件配置：hexo官方文档介绍得非常详细，我们就对主要的几个进行简单介绍和配置。# Site 下面:然后继续,或者直接搜索 ‘theme’ ，把字段改成next，表示使用next主题，如果是使用的其他主题的话，就改成其他主题名字：修改之后，重新生成页面和启动服务，默认样式如下：可以看到我们修改的已经生效了，标题和副标题。如果中文显示乱码的话，记事本打开_config.yml，文件 -&gt; 另存为 -&gt; 选择编码 UTF-8 -&gt; 确定（默认是相同目录，替换就ok） 配置主题站点先暂时配置到这，其他的后面有需要再配置。下面进行主题配置。打开\\themes\\next下的_config.yml文件。其实如果英语比较好的话，里面注释都讲的比较详细了，一直往下设置就ok。不过英语不好的我，只能参考Next文档进行配置。 首先配置整个网站的主题布局等等，就按照Next使用文档的配置顺序来配置一下。 选择主题[Scheme]这个主题是Next的外观，我们可以在主题文件里面搜索 “scheme:”来找到设置位置：这个配置还有一个好处就是：支持动态设定，也就是修改了配置之后不需要重新生成静态文件，开启服务。在之前预览的页面直接刷新就可以了。刷新以后主题外观就改变了。 设置菜单所谓菜单就提供一个按钮，点击之后跳转到不同的地方。菜单设置就刚刚外观设置的上面一个，找不到可以进行搜索”menu“，找到相关字段：Next默认是只有home 和 archives。其他的菜单都被注释了，我们就把需要展示的菜单注释去掉，然后保存并刷新我们的预览页面。就可以看到以下效果了：在这里值得我们注意的是，菜单的设置格式 ，如：” tags: /tags/ || tags “ ； 好在配置文件里面也提供了注释，大致就是说，”名称:链接 || 图标“ 。所谓的名称并不会直接展示在网页上，而是会去\\next\\languages目录下，找到刚刚站点设置的语言文件，在里面进行查找匹配。所以我们在配置文件中写的是英文，但是我们网页展示的却是汉子。如果改成其他语言，自然也会替换成其他语言的文字展示。然后 || 之后的图标，Next会自动到FontAwesome上进行匹配。有兴趣的可以查看自己博客网页的源代码，图标就是使用的fa fa-*格式。在菜单这里还有一点就是，目前我们只能看这个菜单，如果点击的话，会出现404错误 或者是 Cannot GET /*/，这是因为我们本地没有相关的页面提供给它。 那我们就需要新建页面提供给主题进行访问。回到存放博客的根目录下，进行git bash（以标签为例）： 1hexo new page tags 之后我们会发现在博客根路径的source文件夹里面多了一个tags文件夹，我们继续打开就能发现一个index.md文件 ，然后需要编辑这个md文件，来让Next来识别它。我们需要添加一个type字段，添加tags (这个是对应了之前menu设置名称，点击tags菜单就能跳到这个页面)。然后我们重新生成，启动预览就可以点击菜单并且进去了。其他菜单同理。 设置侧边栏所谓侧边栏也就是我们展示我们刚刚菜单的那一栏，在配置文件中搜索Sidebar Settings，就可以看到相关设置。侧边栏可以展示的东西还挺多的，这里我们按照配置文件从上到下进行设置：1.社交链接（Social Links），用于展示其他的社交平。我们先把social的注释去掉，然后把需要展示的选项注释也去掉，在这里的设定格式和之前菜单是一样的，然后我们也可以添加自定义的社交连接。后面也有关于图标的设置，如果上面设置了图标，下面就不用添加了。设置一下是否显示图标和仅显示图标就ok。效果显示： 2.友情连接（Blog rolls），这个功能就不多介绍了，主要看怎么配置吧。效果如下： 3.设置头像（Sidebar Avatar）设置头像有三种方式： 将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在）配置为：avatar: /uploads/文件名 或者 放置在 source/images/ 目录，配置为：avatar: /images/文件名 还有就是直接使用网络连接，配置为：avatar: http://example.com/avatar.png 4.其他还有几个设定不是非常重要，但是也可以设置一下，不然就用默认的都可以。 设置文章内目录 12toc: enable: true 设置侧边栏展示在哪边 12position: left#position: right 侧边栏何时展示 1234#display: post #默认，存在目录列表显示display: always #在所有页面都显示#display: hide #在所有页面都隐藏，需要手动展开#display: remove #完全移除 添加一个内容已经查看的百分比，这个挺有意思的 1scrollpercent: true 第三方服务 网站访问统计，我们采用不蒜子提供的服务。进入不蒜子网页，有手动设置方式。不过现在Next配置文件，已经集成了。手动配置可以更加个性化一点。配置文件就比较方便。直接在配置文件中搜索busuanzi_count ，将下面的enable改成true就可以了。 1enable: true 文章阅读统计，在文件中搜索leancloud_visitors，使用LeanCloud帮助我们统计。先进入LeanCloud进行注册验证，然后新建应用，获取key 和id。随后将其填入我们的配置文件。 1234leancloud_visitors: enable: true app_id: app_key: 更多功能我的博客暂时配置到这里就差不多了（主要是东西挺多的，有点麻烦）。有需要更多炫酷功能可以进行百度查找，其他相关设置。如https://www.jianshu.com/p/f054333ac9e6https://www.jianshu.com/p/3a05351a37dc 新建博文前面的工作做了那么多，当然不仅仅是就搭建一个网站算了，书写博客才是我们的最终目的。在博客根目录下git bash ： 1hexo new title # title 文章标题 然后会提示: Created: D:\\CODE\\bolg2\\source_posts\\title.md 那就说明已经新建了一个新文章，然后照着这个目录找到刚刚新建的文件，打开之后会发现只有这一部分。官方文档称之为Front-matter，用于指定个别文件的变量。在这一部分，预先定义的内容有 layout 布局 title 标题 date 建立日期 updated 更新日期 comments 开启文章的评论功能 true/false tags 标签 categories 分类 permalink 覆盖网站网址一般就设定标题、标签、分类、时间就可以了，标题和时间hexo会自动帮我们加上，所以我们就手动添加标签和分类上去。 123456789---title: testdate: 2019-04-06 20:45:51tags:- Blog- Hexocategories:- learn,hexo --- 这里需要注意的是标签和分类的写法。然后还有分类只支持单分类，也就是说，如果你在分类下面写上两个，会用最后的一份分类指定给文章。不过分类虽然不支持平级，但是可以有从属，也就是父子级分类，使用,分割分类的层次关系。 高级编辑Hexo的博文使用MarkDown语法，多少会受到限制。为了弥补标签的不足，Hexo提供了标签插件来支持博文的多样化。大致分为以下几类 引用块，在文章中插入引言，可包含作者、来源和标题。语法如下： 123&#123;% blockquote [作者, 来源] [链接] [链接标题] %&#125;content&#123;% endblockquote %&#125; []中的为可选项，如引用歌词： 123456&#123;% blockquote [陈宏宇, 早春的树] %&#125;臂弯做衣架摇晃在庭前腰杆做长椅你轻靠,或躺下看书&#123;% endblockquote %&#125; 臂弯做衣架摇晃在庭前腰杆做长椅你轻靠,或躺下看书 [陈宏宇早春的树] 代码块，相对使用反引号而言更加具体描述的引用。 123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 如： 1234&#123;% codeblock [Thread] [lang:Java] [http://tool.oschina.net/apidocs/apidoc?api=jdk-zh] [java jdk] %&#125;PrimeThread p = new PrimeThread(143);p.start();&#123;% endcodeblock %&#125; [Thread] [] [http://tool.oschina.net/apidocs/apidoc?api=jdk-zh] [java jdk]12PrimeThread p = new PrimeThread(143);p.start(); 引用外部资源（图片、视频）图片： 1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; 视频： 12&#123;% youtube video_id %&#125; #插入youtube视频&#123;% vimeo video_id %&#125; #插入vimeo视频 资源文件（添加本地图片）统一管理适合只有少量图片或者需要重复使用的图片。放在主题source/images 文件夹中，通过![](/images/image.jpg)的方法来访问他们。 分散管理适用于每篇博文使用的不同的图片，更加组织化的方式来管理资源。可以非常方便的管理每篇博文的资源。 首先修改站点配置文件，找到post_asset_folder ，设置为true 1post_asset_folder: true 当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径仅输入文件名来引用它们，这样你就得到了一个更简单而且方便得多的工作流。 相对路径引用的标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法![](/example.jpg) ，它将不会出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是 markdown ：通过这种方式，图片将会同时出现在文章和主页以及归档页中。","categories":[{"name":"learn","slug":"learn","permalink":"http://yoursite.com/categories/learn/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"利用Hexo+Github完成搭建个人博客（1-搭建）","slug":"create-hexo1","date":"2019-04-06T14:03:18.000Z","updated":"2019-04-06T14:21:29.639Z","comments":true,"path":"2019/04/06/create-hexo1/","link":"","permalink":"http://yoursite.com/2019/04/06/create-hexo1/","excerpt":"前言​ 最近在学java框架，想利用博客记录下来学习过程以及学习成果，同时也算为自己做一个笔记，平时都是使用Xmind思维导图做笔记，但是在手机上不太方便回顾。本来是打算自己用java写一个博客系统出来，一来记录自己的学习路程，二来可以作为毕业设计，不过考虑到打算重构之前的在线购物系统，以及水平能力有限，便放弃了这个想法。好在无意中接触了hexo，首先hexo的风格吸引了我，画面简洁。其次是功能强大，基本上该有的功能都有。再加上正在学习使用MarkDown书写工具，以及接触GitHub，可以说是各种机缘巧合。正好进行一个系统的全面的学习。​ 我分别在不同的电脑上搭建了两次博客，第一次是笔记本（win10），可以说是磕磕碰碰，最后勉勉强强算搭上了。第二次是在第一次记录的基础上，使用腾讯云服务器（win server 2012）进行搭建，整个过程都非常顺利，这个博客便是第二次搭配记录。跟着这个步骤，最多30分钟便能搭起一个基础的博客。不过基础的博客肯定不能满足后续的要求。 ​ 在下一篇学习页面设置和写/发博客。提前预览​ 建议搭配目录阅读","text":"前言​ 最近在学java框架，想利用博客记录下来学习过程以及学习成果，同时也算为自己做一个笔记，平时都是使用Xmind思维导图做笔记，但是在手机上不太方便回顾。本来是打算自己用java写一个博客系统出来，一来记录自己的学习路程，二来可以作为毕业设计，不过考虑到打算重构之前的在线购物系统，以及水平能力有限，便放弃了这个想法。好在无意中接触了hexo，首先hexo的风格吸引了我，画面简洁。其次是功能强大，基本上该有的功能都有。再加上正在学习使用MarkDown书写工具，以及接触GitHub，可以说是各种机缘巧合。正好进行一个系统的全面的学习。​ 我分别在不同的电脑上搭建了两次博客，第一次是笔记本（win10），可以说是磕磕碰碰，最后勉勉强强算搭上了。第二次是在第一次记录的基础上，使用腾讯云服务器（win server 2012）进行搭建，整个过程都非常顺利，这个博客便是第二次搭配记录。跟着这个步骤，最多30分钟便能搭起一个基础的博客。不过基础的博客肯定不能满足后续的要求。 ​ 在下一篇学习页面设置和写/发博客。提前预览​ 建议搭配目录阅读 1.概述​ Hexo官网：A fast, simple &amp; powerful blog framework,即:快速、简洁且高效的博客框架。基于Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染，只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站，Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。​ 也就是说，只需要30分钟左右就可以搭建一个属于自己的个人博客。同时又有丰富的插件可以使你尽可能的完善自己的博客细节。利用GitHub的git pages，可以托管我们的静态网页，而且可以自定义域名（参考中有）。等博客搭建完毕，我们就只需要写博客内容了。 2.搭建环境2.1 Node.js&emsp; &emsp; 一个JavaScript运行环境,我们使用它来生成我们博客的静态页面。如果不确定自己电脑上是否安装了Node.js,可以在cmd命令行下运行1npm -v ​ 运行结果如下表示未安装： ​ ​ 接下来我们需要去官网下载，进行安装。同时如果版本过低可能会导致部分功能丢失或者配置方法不同，建议6.0以上。​ ​ 安装完成之后我们再运行cmd命令会显示如下结果​ ​ 如果还是提示非命令，有可能是node没有加到环境变量中去，在环境变量的path中，加上刚刚的安装目录。（如我的安装目录：C:\\Program Files\\nodejs\\）有自定义目录需要修改成自定义目录。 2.2 Git 环境​ 接着我们就是需要安装Git了，同时我们先查看一下电脑是否安装了git，在cmd中执行 1git --version ​ 如果显示为非命令，则需要我们下载安装，可以上官网，如果下载较慢的话，也可以上某度云进行下载，安装过程基本上选择默认的就好了。建议版本2.0以上​ 验证是否安装成功同上，不过这次需要加的环境变量则是Git安装目录下的cmd，（如我的：C:\\Program Files\\Git\\cmd） 2.3 Git hub&emsp;&emsp;Git-hub,注册过程就不多赘述，基本上不会有什么问题。重要的是需要建立存放代码的仓库和添加SSHkey保证本地能正常上传代码到github。 1）建立仓库：登陆GitHub之后，在点击右上角的“+”号，选择 new repository。​ 在 Repository name中填入”用户名.github.io”。用户名就是GitHub的用户名。​ 最后点击create repository 这一步就ok了。​ 2）第二步，我们来添加SSHkey,确保我们本地有权限能够提交代码到github。首先我们仍然测试看看本地能否存在key（第一次当然是没有，不过为了和后面出现对比，我们可以先测试一下）。首先在桌面右击 -&gt; 选择Git Bash Here调出git命令台。输入下面命令： bash1ssh -T git@github.com 如果提示&lt; Are you sure you want to continue connecting (yes/no)?&gt;，输入yes ​ 这就是本地没有权限连接的，需要我们创建SSHkey。我们继续输入以下命令 bash1ssh-keygen -t rsa -C &quot;注册github的邮箱&quot; ​ 三次回车之后，会出项下面的结果：​ 然后git会自动在c盘用户下面的当前用户文件夹新建一个.ssh文件，里面有一个 id_rsa.pub 文件。使用记事本打开之后，复制里面的内容。​ 我们在本地生成好key之后，需要添加到github上。在GitHub网页进入个人设置选择SSH and GPG keys，新建一个ssh key：​ 把复制过来的内容粘贴在key框，上面的title可以写，也可以不写，不写会默认使用邮箱。如果为了区分多台客户端，可以填写区分一下。​ 保存之后，输入密码确认，跳转到sshkey页面，你会发现刚刚添加的key已经在里面了。到这里我们就已经添加成功了，于是我们再测试一下连接，出现以下结果就是正确的。 ​ 然后再运行以下命令，来让git记录我们的身份bash12git config --global user.name &quot;GitHub账号&quot;git config --global user.email &quot;注册邮箱&quot; ​ 到这里我们的准备工作就已经结束了。下面就开始搭建博客，如果到这里就放弃，那就前功尽弃了（加油）。 3.搭建博客3.1 安装hexo​ git bash 执行以下代码：bash1npm install -g hexo 可能会要一点时间，如果没有报错(ERR)，说明安装问题。 3.2搭建博客新建一个文件夹，用来存放我们的博客文件。右键 -&gt;git bash，依次运行以下代码。‘#’后面是注释 bash123hexo init #初始化hexo环境hexo g #生成静态页面hexo s #开启本地服务 执行完最后一条命令，会出现如上结果。从图中我们也得知，在浏览器输入&lt; http://localhost:4000/ &gt; 就可以浏览我们的博客了，然后按ctrl + c 结束本地服务。生成的静态文件就在public文件夹中。 至此我们就快大功告成，把代码同步到github让它帮我们管理代码。同时，我们也可以输入之前我们定义的仓库名，进行外网访问。不过，我们还要进行最后一步配置。 3.3配置并同步代码用文本文件打开刚刚存放博客文件的目录中的 `_config.yml` 文件，然后拉到最后找到deploy: 按照如下进行配置，冒号后面一定要跟空格： 1234deploy: type: git repository: git@github.com:GitHub用户名/GitHub用户名.github.io.git branch: master ​ GitHub用户名就是刚刚新建仓库的名称。保存之后，再依次运行以下命令： bash12npm install hexo-deployer-git --save #安装插件hexo d #上传代码 上传成功之后，然后我们可以到我们GitHub的仓库下看看，是不是把本地的文件上传过去了。然后我们利用其它的浏览器，或者客户端输入 刚刚定义的仓库名称 &lt; https://licqing.github.io/ &gt;就可以访问你的博客了。 ​ 搭建博客的结束，正是入门博客的开始。hexo文档。后续将配置博客样式和书写博客。 4.途中遇见的问题说说第一次搭配遇到的问题和最后怎么解决的吧。 hexo init 命令 ： 错误 conmand not found 。应该是hexo未配置进环境变量，我们找到node_modules文件夹,这时我们发现里面有很多文件夹，找到hexo文件夹,这里我们可以看到一个bin文件夹，进到bin。然后把这个目录加到环境变量path中去。 hexo init 命令 ： 错误 FATAL not empty。存放博客的地方一定是需要空文件夹。注意检查空文件夹。 hexo g 命令 ： 错误 FATAL bad indentation of a mapping entry at line 82, column 13。 _config.yml文件冒号后面没有跟空格 5.参考（可配置域名） https://www.jianshu.com/p/05289a4bc8b2 https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html https://hexo.io/zh-cn/docs/writing","categories":[{"name":"learn","slug":"learn","permalink":"http://yoursite.com/categories/learn/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-04-03T15:05:48.930Z","updated":"2019-04-03T15:05:48.931Z","comments":true,"path":"2019/04/03/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}